
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://akane.github.io/blog/Math/Linear%20Algebra/01-02%20%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B/">
      
      
      
      
      <link rel="icon" href="../../../assets/MIKASA.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>01 02 求解线性方程 - Akane's blog</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
    
    
      <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css">
    
      <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css">
    
      <link rel="stylesheet" href="https://cdn.tonycrane.cc/utils/katex.min.css">
    
      <link rel="stylesheet" href="https://cdn.tonycrane.cc/jbmono/jetbrainsmono.css">
    
      <link rel="stylesheet" href="https://cdn.tonycrane.cc/lxgw/lxgwscreen.css">
    
      <link rel="stylesheet" href="../../../css/custom.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="Akane&#39;s blog" class="md-header__button md-logo" aria-label="Akane's blog" data-md-component="logo">
      
  <img src="../../../assets/MIKASA.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Akane's blog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              01 02 求解线性方程
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/Akane-6730/blog" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../.." class="md-tabs__link">
          
  
  
    
  
  Home

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../CS/PracticalSkills/" class="md-tabs__link">
          
  
  
    
  
  CS

        </a>
      </li>
    
  

    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../Language/English/%E5%A4%A7%E8%8B%B1%E2%85%A2/VLS%E2%85%A1/" class="md-tabs__link">
          
  
  
    
  
  Language

        </a>
      </li>
    
  

    
  

    
  

      
        
  
  
  
  
    
    
      
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../CTF/Crypto/Introduction%20to%20CryptoHack/" class="md-tabs__link">
          
  
  
    
  
  CTF

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Akane&#39;s blog" class="md-nav__button md-logo" aria-label="Akane's blog" data-md-component="logo">
      
  <img src="../../../assets/MIKASA.png" alt="logo">

    </a>
    Akane's blog
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/Akane-6730/blog" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../.." class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_1" id="__nav_1_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Home
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../about/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    About
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    CS
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            CS
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../CS/PracticalSkills/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    PracticalSkills
    
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            PracticalSkills
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/PracticalSkills/Shell/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Shell
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/PracticalSkills/Git/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Git
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_4" >
        
          
          <label class="md-nav__link" for="__nav_2_1_4" id="__nav_2_1_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Editor
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_4">
            <span class="md-nav__icon md-icon"></span>
            Editor
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/PracticalSkills/Emacs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Emacs
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_5" >
        
          
          <label class="md-nav__link" for="__nav_2_1_5" id="__nav_2_1_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Build Tool
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_5">
            <span class="md-nav__icon md-icon"></span>
            Build Tool
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/PracticalSkills/Make/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Fancier Make Options
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1_6" >
        
          
          <label class="md-nav__link" for="__nav_2_1_6" id="__nav_2_1_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Debugging Tools
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_1_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1_6">
            <span class="md-nav__icon md-icon"></span>
            Debugging Tools
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/PracticalSkills/GDB.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    gdb
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/PracticalSkills/Valgrind.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Valgrind
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/PracticalSkills/Compile%20%28gcc%29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Compile (gcc)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    编程语言
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            编程语言
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
          
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_1" >
        
          
          <div class="md-nav__link md-nav__container">
            <a href="../../../CS/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" class="md-nav__link ">
              
  
  
  <span class="md-ellipsis">
    C
    
  </span>
  

            </a>
            
          </div>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_1">
            <span class="md-nav__icon md-icon"></span>
            C
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Language
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Language
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    English
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            English
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1" id="__nav_3_1_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    大英Ⅲ
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1">
            <span class="md-nav__icon md-icon"></span>
            大英Ⅲ
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Language/English/%E5%A4%A7%E8%8B%B1%E2%85%A2/VLS%E2%85%A1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    VLSⅡ
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Language/English/%E5%A4%A7%E8%8B%B1%E2%85%A2/IC%E2%85%A1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ICⅡ
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    CTF
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            CTF
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
      
        
      
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Crypto
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1">
            <span class="md-nav__icon md-icon"></span>
            Crypto
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../CTF/Crypto/Introduction%20to%20CryptoHack/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introduction to CryptoHack
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    <span class="md-ellipsis">
      1.1. 矩阵形式的方程
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
    <a href="https://github.com/Akane-6730/blog/edit/master/docs/Math/Linear Algebra/01-02 求解线性方程.md" title="编辑此页" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg>
    </a>
  
  


<blockquote>
<p>求解线性方程 Solving Linear Equations</p>
</blockquote>
<h1 id="1">1. 向量和线性方程</h1>
<blockquote>
<p>Vector and Linear Equations</p>
</blockquote>
<p>线性代数的核心问题是求解线性方程组.线性的,意味着未知数只是乘以数字,我们不会看见 <span class="arithmatex">\(x*y\)</span>.我们第一个线性系统箱单简单.但先提一下大纲:假设是n个方程组n个未知数,有三种图像可以描述这些方程组</p>
<ol>
<li><strong>行视图(row picture)</strong>: 最熟悉的图像,也就是一个行图像代表一个方程组.比如两个方程的直线相交. <strong>理解为求交点</strong></li>
<li><strong>列试图(column picture)</strong>: 很重要.可以理解为每一列组成一个图像.所有的行和列组成矩阵. <strong>理解为向量组合</strong></li>
<li>最后,我们从矩阵的形式来看到问题.</li>
</ol>
<p>用线性组合的语言来说,就是,<strong>列的线性组合是否能覆盖整个三维空间(也就是能产生任意的b,所有的b)?</strong> 对于上面的例子,答案是可以的.因为这里的矩阵A是个非奇异矩阵.但是其他的矩阵有可能不行.如果上面的三列向量都在同一个平面的时候,那么它们的线性组合肯定逃不出这个平面,它们的组合得到的b只可能是这个平面之内的.这种情况下,矩阵就是<strong>奇异的.</strong></p>
<h2 id="11">1.1. 矩阵形式的方程</h2>
<blockquote>
<p>The matrix form of Equations </p>
</blockquote>
<p>三维例子当中,行视图有3行,列视图有3列.这三行三列包含了9个数字,可以形成一个3*3的矩阵A
$$
\text{The coefficient matrix in }A x = b \quad \text { is } \quad A = \left[ \begin{array} { r r r } 1 &amp; 2 &amp; 3 \ 2 &amp; 5 &amp; 2 \ 6 &amp; - 3 &amp; 1 \end{array} \right]
$$
A代表的是一个9个系数的矩阵.b代表的是一个列向量.未知数x也是一个列向量.如果使用行形式,那么就是<code>Eq(3)</code>,如果列形式,那么就是<code>Eq(4)</code>.如果是矩阵,那么就是
$$
\text{Matrix equation Ax = b:} \qquad </p>
<p>\left[ \begin{array} { l l l } 1 &amp; 2 &amp; 3 \ 2 &amp; 5 &amp; 2 \ 6 &amp; - 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l } x \ y \ z \end{array} \right] = \left[ \begin{array} { l } 6 \ 4 \ 2 \end{array} \right]</p>
<p>\tag{5}
$$
基本问题:矩阵A乘以列向量x是什么意思?我们可以通过行乘也可以通过列乘.Ax = b.两种方式都完成一共9次乘法:</p>
<blockquote>
<p><strong>Multiplication by rows:</strong> Ax的结果是点乘:A的每一行都乘以列向量x:
$$
A x = \left[ \begin{array} { l } ( \operatorname { row } 1 ) \cdot x \ ( \text {row } 2 ) \cdot x \ ( \text {row } 3 ) \cdot x \end{array} \right]  \tag{6}
$$</p>
<hr />
<p><strong>Multiplication by columns</strong>  : Ax是列的线性组合
$$
A x = x ( \text {column } 1 ) + y ( \text {column} 2 ) + z ( \text {column } 3 ) \tag{7}
$$</p>
</blockquote>
<p>当把解x = (0,0,2)替换进去,乘法Ax 可以产生b
$$
\left[ \begin{array} { r r r } 1 &amp; 2 &amp; 3 \ 2 &amp; 5 &amp; 2 \ 6 &amp; - 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l } 0 \ 0 \ 2 \end{array} \right] = 2 \text { times column } 3 = \left[ \begin{array} { l } 6 \ 4 \ 2 \end{array} \right]
$$</p>
<p>而行点乘x的方式,每次点乘得到b的一个分量.<strong>Ax应该看成是A的列的线性组合.</strong></p>
<h1 id="2">2. 消去的思想</h1>
<p>这一节,学习一个系统的方法来求解线性方程组.这个方法叫做<strong>消去(Elimination)</strong>.如下例子:
$$
\text{消去之前:}\quad
\begin{aligned} x - 2 y &amp; = 1 \ 3 x + 2 y &amp; = 11 \end{aligned}
\[3ex]</p>
<p>\text{消去,Eq(2) -3*Eq(1):} \quad</p>
<p>\begin{aligned}
x- 2y &amp;= 1 \
8y &amp; = 8
\end{aligned}
$$
在消去之前,x,y同时出现在两个等式当中,消去之后,未知数x在第2个方程里面消失了,第二个方程变成8y = 8,立刻知道y = 1.把y替换回去,得到x = 3.</p>
<p>消去产生了一个<strong>上三角系统(upper triangular system)</strong>--这就是我们的目标.非0的系数<code>1,-2,8</code> 形成一个三角形.这样这个系统就可以<strong>从下往上解</strong>--先求出y然后是x.这个过程叫做<strong>向后替换(back substitution)</strong></p>
<p>Fig2.5展示了消去前后的两个系统的直线方式相交的图像.消去之后他们还是相同的交点</p>
<p><img alt="image-20201229235829979" src="../.assets/image-20201229235829979.png" /></p>
<p>在本例中,消去的思想是:<strong>为了消去x,用 <code>方程2-方程1*倍数</code></strong>. 那么,倍数这个乘数(multipler),用 <span class="arithmatex">\(\ell\)</span> 表示?是怎么找到的呢?先定义两个概念:</p>
<ul>
<li><strong>主元(Pivot))</strong>:系数矩阵<strong>行中第一个不为0</strong>的系数,比如在上面的例子当中,我们消去的是x,第一个方程 <code>x-2y=1</code> 参与消去.主元就是x的系数1</li>
<li><strong>乘数(Multiplier)</strong>:由被消去的未知数的系数和主元得到,这个例子当中就是
<code>3x+2y = 11</code> 的x的系数3除以主元1,所以乘数就是: <span class="arithmatex">\(系数/主元= 3/1 = 3\)</span>. ,<span class="arithmatex">\(Eq(2) - Eq (1) * multlplier\)</span>,就消去了x</li>
</ul>
<p>如果方程变成
$$
\begin{aligned}
4x - 8y &amp;= 4 \
3x + 2y &amp;= 11
\end{aligned}</p>
<p>\overset{消去}{ \Rightarrow} \quad </p>
<p>\begin{aligned}
4x - 8y &amp;= 4 \
8y  &amp;= 8
\end{aligned}
$$
过程是:主元是4,乘数是3/4,那么 <span class="arithmatex">\(Eq(2) - 3/4 * Eq(1)\)</span> 即可消去x.</p>
<p>再看看这个消去x后的式子.假如有第三个方程,我们想要在<strong>第三个</strong>方程中消去y.那么<strong>方程2</strong>的y的系数可以当做主元了,所以这次的主元是8...可以推理得到,为了求解n个方程,我们需要n个主元.而且注意:<strong>这些主元,是在消去后上三角矩阵的的对角线上.注意,当对角线上的这些主元存在0的时候,消去会失败</strong>,理解消去失败的例子,你会明白消去的整个过程.</p>
<h2 id="_1">消去失败</h2>
<blockquote>
<p>Breakdown Of Elimination</p>
</blockquote>
<ul>
<li><strong>消去失败:</strong> n个方程不能得到n个主元,消去失败</li>
<li>消去后得到 <span class="arithmatex">\(0 \ne 0\)</span>，<strong>没有解</strong>,如果得到 <span class="arithmatex">\(0=0\)</span>,有很多解</li>
<li>如果成功得到n个主元,就可以成功解方程,但有可能需要<strong>交换方程</strong></li>
</ul>
<hr />
<p>例1例2是<strong>奇异的(Singular)</strong>--没有第二个主元.例3<strong>是非奇异的(nonsingular)</strong>.主元全部存在,并且有<strong>恰好一个</strong>解.<strong>主元必须是非0的,因为必须除以它.奇异方程组没有解或者无穷多的解.</strong></p>
<h2 id="_2">三个方程,三个未知数</h2>
<blockquote>
<p>Three Equations in Threee unknowns  </p>
</blockquote>
<p>为了理解<strong>高斯消去法(Gaussian Elimination)</strong>,我们需要比2-2的矩阵更深入一点.3-3足够看清楚这个模式了.目前,矩阵都是正方形的:行数和列数是相同的.下面是一个特殊构建的3-3的系统
$$
\begin{array} { r } 2 x + 4 y - 2 z = 2 \ 4 x + 9 y - 3 z = 8 \ - 2 x - 3 y + 7 z = 10 \end{array} \tag{1}
$$</p>
<p>第一个主元是左上角的2.在这个下面下面我们想要消去4.那么乘数就是<code>4/2 = 2</code>. <code>方程2 - 方程1 * 2</code>.可以在方程2消去x</p>
<p><strong>第1步:</strong> <code>Eq(2) - 2 *Eq(1)</code>,等式2变成: <span class="arithmatex">\(y+z = 4\)</span></p>
<p>第三个方程也消去x，主元不变，乘数是 <span class="arithmatex">\(-2/2 = -1\)</span>.所以是 <code>方程3+方程1</code>,但<strong>思想还是减</strong>,乘数是-1,也就是方程3 - 方程1*(-1)).</p>
<p><strong>第2步:</strong> <code>Eq(3) - (-1)  *Eq(1)</code>,等式3变成: <span class="arithmatex">\(y+5z = 12\)</span></p>
<p>现在得到两个<strong>只有yz</strong>的新方程.现在第二个主元就是1(左上角)，系数矩阵是2-2的:
$$
\text{x消去后:} \quad </p>
<p>\begin{aligned}
1y + 1z &amp;= 4 \
1y+  5z&amp;= 12
\end{aligned}
$$
最后一步，就是消去y,得到1-1的系统</p>
<p><strong>第3步:</strong> 乘数是 <code>1/1 = 1</code>,<span class="arithmatex">\(Eq(3)_{new} - Eq(2)_{new}\)</span>,得到: 4z = 8</p>
<p>现在初始的Ax = b变成了一个新的<strong>上三角 Ux = c</strong>
$$
Ax = b \text{ becomes Ux = c:}
\qquad 
\begin{array} { r } 2 x + 4 y - 2 z = 2 \ 1 y + 1 z = 4 \ 4 z = 8 \end{array}</p>
<p>\tag{2}
$$
我们的目标达到了--从A到U我们实现了<strong>向前消去(forward elimination)</strong>.注意主元是2,1,4,<strong>在U的对角线上</strong>.在初始的系统中,主元是隐藏的,消去发现了它们.Ux = c现在就做好了向后替换的准备:4z =8得到z = 2,y+z = 4得到y = 2,最后x = -1</p>
<p>那么解就是 <span class="arithmatex">\((x,y,z) = (-1,2,2)\)</span>.原始的系统Ax=b当中,的xyz和三角系统Ux = c的是结果是一样的</p>
<hr />
<p>对于 <code>4-4</code> 的系统和 <code>n-n</code> 的系统,过程是一样的.下面是这整个思想,当消去成功的时候,这样就能<strong>一列列的从A得到三角的U</strong></p>
<blockquote>
<ul>
<li>列1:使用方程1,在第1个主元<strong>之下</strong>产生系数0（sp:可能多个0，当方程数 <span class="arithmatex">\(n \ge 3\)</span>,比如前面3个方程例子，对第一个主元下方的位置，方程<code>2，3</code>都要产生系数0）</li>
<li>列2:使用 <strong>新的</strong> 方程2,在第2个主元<strong>之下</strong>产生系数0（sp：如上，可能多个0）</li>
<li><code>列3-列n</code>:一直进行上述过程,找到n个主元,从而产生上三角矩阵U</li>
</ul>
</blockquote>
<p>前进消去的结果就是一个上三角系统,如果存在全部的n个主元(从不为0!),那么就是非奇异的.</p>
<h2 id="21-e">2.1. 视频例子:消去矩阵E</h2>
<blockquote>
<p>sp:这个例子可作为下一节的过度</p>
</blockquote>
<p>假设方程组如下
$$
\begin{array} { r } x + 2 y + z = 2 \ 3 x + 8 y + z = 12 \ 4 y + z = 2 \end{array}
$$
实际上能不能求出解,<strong>取决于矩阵A</strong>.系数矩阵A是
$$
\left[\begin{matrix} 
1 &amp; 2 &amp; 1\
3 &amp; 8 &amp; 1\
0 &amp; 4 &amp; 1\
\end{matrix} \right]
$$
我们的目的是消元,比如想要消去方程2的x.看系数矩阵,第一行第一个数字,也就是主元.是1,而第二行需要被消去的数字是3.所以乘数是3,那么，进行 <span class="arithmatex">\(r2 -r1*3\)</span>,x就被消去.矩阵A变成
$$
\left[\begin{matrix} 
1 &amp; 2 &amp; 1\
0 &amp; 2 &amp; -2\
0 &amp; 4 &amp; 1\
\end{matrix} \right]
$$
第二个消去的目标是行3第1个数字,也就是0,不用再消去了.(这时候的主元还是行1第一个数字,1)</p>
<p>下一步,主元变成行2第二个数字,我们希望消去的是行3第二个数字.乘数这时候是2.那么 <span class="arithmatex">\(r_3 - r2 * 2\)</span>,矩阵最终变成
$$
\left[\begin{matrix} 
1 &amp; 2 &amp; 1\
0 &amp; 2 &amp; -2\
0 &amp; 0 &amp; 5\
\end{matrix} \right]
$$
这就是最终的矩阵U,<strong>上三角矩阵</strong>.消元最终把矩阵A变成了U.主对角线上的三个数字1,2,5都是主元.</p>
<hr />
<p>现在看看消元失效的情况.什么情况下会失效呢?也就是不能得到三个主元.失效有好几种情况,比如,如果一开始行1的第1个数字是0,那么没有第一个主元,怎么办呢?并不意味着没有解,我们需要的是行交换.</p>
<p>再看另外一个问题,U矩阵(2,2)位置上的主元什么时候可能是0呢?如果把A矩阵(2,2)位置的8写成6,那么U(2,2)位置就变成了0,但是我们还是可以行交换,只要0下面有非0元素.</p>
<p>如果把A的(3,3)位置改成-4,这时候是无法修复的.因为最终它变成了0,不存在第3个主元了.消元失效!</p>
<p>可以通过行交换的失效只是暂时失效,而如果行交换都不能解决,那么就是永久失效了.</p>
<hr />
<p>现在把右侧的b也加进来,得到增广矩阵
$$
\left[\begin{matrix} 
1 &amp; 2 &amp; 1 &amp; 2\
3 &amp; 8 &amp; 1 &amp;12\
0 &amp; 4 &amp; 1 &amp; 2\</p>
<p>\end{matrix} \right]
$$
实际上我们在消去的时候,<strong>右侧的b也是会同步变化的</strong>.那么当A化为U的时候,这个最终的增广矩阵就是
$$
\left[\begin{matrix} 
1 &amp; 2 &amp; 1 &amp;2 \
0 &amp; 2 &amp; -2 &amp;6\
0 &amp; 0 &amp; 5 &amp; -10\
\end{matrix} \right]
$$
原始方程变成
$$
\begin{array} { r } </p>
<p>x + 2 y + z &amp;= 2 \ 
2 y - 2z &amp;= 12 \ 
5z &amp;= -10 
\end{array}
$$
回带先求出z = -2,然后是y = 1最后是x=2.(这是因为U是上三角的)。</p>
<hr />
<p>在上面的消元当中，我们的确进行了消元，<strong>但没有使用矩阵的方式</strong>。下面我们对下面矩阵A用<strong>矩阵的方式消元</strong>
$$
\left[\begin{matrix} 
1 &amp; 2 &amp; 1\
3 &amp; 8 &amp; 1\
0 &amp; 4 &amp; 1\
\end{matrix} \right]
$$
<strong>矩阵A乘以列向量其实就是A的列的线性组合</strong>.现在看看一个行向量乘以一个矩阵,比如
$$
\left[\begin{matrix} 
1 &amp; 2 &amp; 7 \ 
\end{matrix} \right]</p>
<p>\left[\begin{matrix} 
- &amp; - &amp; -\
- &amp; - &amp; -\
- &amp; - &amp; -\
\end{matrix} \right]</p>
<p>= \left[\begin{matrix} 
1<em>r_1 &amp; 2</em> r_2 &amp; 7*r_3 \ <br />
\end{matrix} \right]</p>
<p>\quad \color{orange} \text{结果是一个行向量}
$$
其实是对<strong>行进行线性组合</strong>!</p>
<p>什么样的矩阵E能做到,<strong>左乘</strong>A，可以让A的 <span class="arithmatex">\(r2 - 3* r1\)</span> ?也就是
$$
\left[\begin{matrix} 
- &amp; - &amp; -\
- &amp; - &amp; -\
- &amp; - &amp; -\
\end{matrix} \right]</p>
<p>\left[ \begin{array} { l l l } 1 &amp; 2 &amp; 1 \ 3 &amp; 8 &amp; 1 \ 0 &amp; 4 &amp; 1 \end{array} \right] = \left[ \begin{array} { l l r } 1 &amp; 2 &amp; 1 \ 0 &amp; 2 &amp; - 2 \ 0 &amp; 4 &amp; 1 \end{array} \right]
$$
首先看看,E的第一行是什么呢?因为最终右侧矩阵的第一行和A一样,<strong>根据右左乘矩阵是对矩阵的行进行线性组合</strong>,我们得到,E的第一行应该是 <code>1 0 0</code>,也就是只取A的r1,r2和r3不要.同理,E的r3是 <code>0,0,1</code>. 已经有了r1,r3,现在缺r2.我们想要A的 <span class="arithmatex">\(r_2 - 3*r_1\)</span>.根据行的线性组合E应该是
$$
\left[\begin{matrix} 
1 &amp; 0 &amp; 0\
-3 &amp; 1 &amp; 0\
0 &amp; 0 &amp; 1\
\end{matrix} \right]</p>
<p>= E_{21}
$$
这个矩阵E叫做初等矩阵或者消去矩阵.并且它在(2,1)位置上有特殊的用来把A(2,1)位置变成0做消去的元素.所以我用<span class="arithmatex">\(E_{21}\)</span> 表示.</p>
<p>现在,A经过一个消去之后变成了
$$
\left[ \begin{array} { l l r } 1 &amp; 2 &amp; 1 \ 0 &amp; 2 &amp; - 2 \ 0 &amp; 4 &amp; 1 \end{array} \right]
$$
下一个目标是要把(3,2)位置变成0,这时候 <span class="arithmatex">\(E_{32}\)</span> 是什么呢.同理,我们可以得到
$$
\left[\begin{matrix} 
1 &amp; 0 &amp; 0\
0 &amp; 1 &amp; 0\
0 &amp; -2 &amp; 1\
\end{matrix} \right]
$$
也就是说
$$
\left[ \begin{array} { c c c } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; - 2 &amp; 1 \end{array} \right] \left[ \begin{array} { c c r } 1 &amp; 2 &amp; 1 \ 0 &amp; 2 &amp; - 2 \ 0 &amp; 4 &amp; 1 \end{array} \right] = \left[ \begin{array} { c c c } 1 &amp; 2 &amp; 1 \ 0 &amp; 2 &amp; - 2 \ 0 &amp; 0 &amp; 5 \end{array} \right]
$$
最终,我们使用了矩阵操作得到了最终的消去结果.使用的是一连串的初等矩阵E.过程如下
$$
E_{32} (E_{21} A) = U
$$
多么简洁美丽啊</p>
<hr />
<p>再考虑一个问题,把矩阵A变成U,有没有一个矩阵可以一次性完成任务,而不是一连串的E.其实这个矩阵也就是所有E的组合!对于矩阵乘法,矩阵的顺序不能改变,但是可以改变括号的顺序,也就是说
$$
E_{32} (E_{21} A) = (E_{32} E_{21}) A 
$$
这样可以得到单个矩阵,叫做E.</p>
<p>还有另外一个初等矩阵,他可以交换两行.称为P矩阵,也就是<strong>置换矩阵(permutation matrix)</strong>.其实也很简单,假设要交换的矩阵是3-3,要交换行1和行2,那么这个<span class="arithmatex">\(P_{12}\)</span> 是
$$
\left[\begin{matrix} 
0 &amp; 1 &amp; 0\
1 &amp; 0 &amp; 0\
0 &amp; 0 &amp; 1\
\end{matrix} \right]
$$
如果我们想要交换的是列呢?注意，对列的操作是<strong>右乘</strong>。 假设我们要交换的矩阵是 <span class="arithmatex">\(\left[\begin{matrix} a &amp; b \\ c &amp; d \end{matrix} \right]\)</span>，想要得到: <span class="arithmatex">\(\left[\begin{matrix} b &amp; a \\ d &amp; c \end{matrix} \right]\)</span>.那么
$$
\left[ \begin{array} { l l } a &amp; b \ c &amp; d \end{array} \right] \left[ \begin{array} { l l } 0 &amp; 1 \ 1 &amp; 0 \end{array} \right] = \left[ \begin{array} { l l } b &amp; a \ d &amp; c \end{array} \right]
$$</p>
<p>现在我们已经知道,<span class="arithmatex">\(E_{32} E_{21}\)</span> 可以得到一个一次性把A变成U的矩阵,但是现在我们不打算这么做,因为有更好的方法.我们先不管A怎么变成U,而是看U怎么变成A.这一节课的所有矩阵都是可逆的,现在是了解逆矩阵的好时机.</p>
<p>现在看看我们的 <span class="arithmatex">\(E_{21}\)</span>,我想要用一个矩阵来逆转 <span class="arithmatex">\(E_{21}\)</span> 所做的变化(<span class="arithmatex">\(E_{21}\)</span> 所做的变化是什么呢?就是 <span class="arithmatex">\(r_2 - 3r_1\)</span>) .其实也就是想要一个矩阵,得到
$$
\left[\begin{matrix} 
- &amp; - &amp; -\
- &amp; - &amp; -\
- &amp; - &amp; -\
\end{matrix} \right]</p>
<p>\underbrace{
\left[\begin{matrix} 
1 &amp; 0 &amp; 0\
-3 &amp; 1 &amp; 0\
0 &amp; 0 &amp; 1\
\end{matrix} \right]
}<em 21="21">{E</em>}</p>
<p>= </p>
<p>\underbrace{\left[\begin{matrix} 
1 &amp; 0 &amp; 0\
0 &amp; 1 &amp; 0\
0 &amp; 0 &amp; 1\
\end{matrix} \right]
}_{\quad \color{orange} \text{Identify Matrix I}}
$$
其实就是 <span class="arithmatex">\(E_{21}\)</span> 的 <span class="arithmatex">\(r_2 + 3r_1\)</span>,那么这个矩阵是
$$
\left[\begin{matrix} 
1 &amp; 0 &amp; 0\
3 &amp; 1 &amp; 0\
0 &amp; 0 &amp; 1\
\end{matrix} \right]
$$
这就是<strong>逆矩阵</strong></p>
<h2 id="22">2.2. 关键概念</h2>
<ol>
<li>经过消去之后,一个线性系统 <span class="arithmatex">\(Ax  =  b\)</span> 变成上三角的 <span class="arithmatex">\(Ux = c\)</span></li>
<li><span class="arithmatex">\(乘数  = 要被消去元素的系数/主元\)</span>  .  主元永远不能为0!</li>
<li>如果主元位置出现0,但是它下面有非0元素,可以通过行交换修复</li>
<li>上三角系统可以通过向后替换求解,也就从下面开始求解等式</li>
<li>当消去是永久失败的时候(permanent faliure),系统不是<strong>没有解</strong>,就是有<strong>无穷多的解</strong></li>
</ol>
<h1 id="3">3. 使用矩阵消去</h1>
<p>我们现在融合两种思想: <strong>消去</strong>和<strong>矩阵</strong>，目标是把消去的所有步骤(和最终结果)以最清晰的方式表达.在上一节 <code>3-3</code> 的例子当中,消去过程还可以使用语言来表达.对于大系统,一长串的步骤描述很让人绝望的.通过一个矩阵E,你会看到,怎么从row i 减去一个row j的数乘</p>
<p>Ax = b的例子如下.和上一节是一样的
$$
\begin{array} { r } 
2 x_1 + 4 x_2 - 2 x_3 = 2 \ 
4 x_1 + 9 x_2 - 3 x_3 = 8 \ 
- 2 x_1 - 3 x_2 + 7 x_3 = 10 
\end{array}</p>
<p>\quad \Rightarrow  \quad</p>
<p>\left[ \begin{array} { r r r } 2 &amp; 4 &amp; - 2 \ 4 &amp; 9 &amp; - 3 \ - 2 &amp; - 3 &amp; 7 \end{array} \right] \left[ \begin{array} { l } x _ { 1 } \ x _ { 2 } \ x _ { 3 } \end{array} \right] = \left[ \begin{array} { r } 2 \ 8 \ 10 \end{array} \right] \tag{1}
$$
注意上面灯饰，矩阵A <strong>乘以</strong> 向量 x，也就是 <strong>作用</strong> 在向量x上，得到一个新向量。如果方程数目和未知数的<strong>个数</strong>一样，那么A就是<strong>方阵</strong>。在<code>Eq(1)</code>,A是<code>3-3</code>方阵。Ax的规则是如此重要,值得再多提一次:</p>
<blockquote>
<p><strong>Ax是A的列的线性组合</strong>.<span class="arithmatex">\(\vec{x}\)</span> 的分量,乘以了A的列:
$$
Ax = x_1 * \text{Column 1} + ...+ x_n * \text{Column n}
$$
</p>
</blockquote>
<p>而当我们计算Ax的某个分量的时候,我们使用<strong>行形式</strong>的矩阵乘法： Ax的第i个组件,是A的第i行和x的点乘:    </p>
<blockquote>
<p><strong>Ax结果的分量,是A的行和x的点乘</strong>:
$$
\text{Ax的第i个分量是: } a_{i1}x_1+a_{i2}x_2+...+a_{in}x——n = \sum_{j=1}^{n}a_{ij}x_j \quad \color{orange} \text{A的第i行，点乘x}
$$</p>
</blockquote>
<h2 id="31">3.1. 矩阵形式的消去步骤</h2>
<blockquote>
<p>The Matrix Form of Elimination Step </p>
</blockquote>
<p>Ax =b对于表达初始方程组的便利形式.但是消去步骤是什么样的呢?在上一节例子当中(本节<code>Eq(1)</code>方程组),第一步是 <span class="arithmatex">\(r_2 - 2r_1\)</span>,在右边,也是b的第2个分量也减去第一个分量的2倍
$$
\text{First step: } \quad
b = \left[ \begin{array} { r } 2 \ 8 \ 10 \end{array} \right] \quad \text { changes to } \quad b _ { \text {new } } = \left[ \begin{array} { r } 2 \ 4 \ 10 \end{array} \right]
$$
我们想要通过矩阵来做这个减法!.我们用一个"消去矩阵"(Elimination matrix)乘以b的时候,可以得相同的值: <span class="arithmatex">\(b_{new}=Eb\)</span>.这个消去矩阵是
$$
E = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right]
$$
乘以这个E将会把b的 <span class="arithmatex">\(第2行 -  (2*第一行)\)</span>.第1行和第3行保持不变
$$
\left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \left[ \begin{array} { l } b _ { 1 } \ b _ { 2 } \ b _ { 3 } \end{array} \right] = \left[ \begin{array} { c } b _ { 1 } \ b _ { 2 } - 2 b _ { 1 } \ b _ { 3 } \end{array} \right]
$$
E的1,3行和单位矩阵 <code>I</code> 是一样的.类似于E的矩阵叫做初等矩阵(elementary matrix)或者消去矩阵.这样的矩阵是怎么来的呢?从单位矩阵 <code>I</code> 开始,把其中一个0变成 <span class="arithmatex">\(-\ell\)</span></p>
<blockquote>
<p>单位矩阵在对角线都是1,其他位置都是0.那么对于任何b,<span class="arithmatex">\(Ib  = b\)</span>,消去矩阵 <span class="arithmatex">\(E_{ij}\)</span>,把目标矩阵的 <code>行i</code> 减去 <code>行j</code> 的 <span class="arithmatex">\(\ell\)</span> 倍,所以E有一个额外的非0元素: 就是在 <code>(i,j)</code>  的位置的值是<span class="arithmatex">\(-\ell\)</span>.</p>
</blockquote>
<p>如下的 <span class="arithmatex">\(E_{31}\)</span> 在 <code>(3,1)</code> 位置有  <span class="arithmatex">\(-\ell\)</span>.
$$
\text{Identity } I = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \quad \text { Elimination } \quad E _ { 31 } = \left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ - \ell &amp; 0 &amp; 1 \end{array} \right]
$$
当你用 <code>I</code> 乘以b,你仍然得到b.但是 <span class="arithmatex">\(E_{31}\)</span> 乘以b之后,是会把b的 <span class="arithmatex">\(r_3 - \ell r_1\)</span></p>
<hr />
<p><strong>Ax =b的左边页同样乘以<span class="arithmatex">\(E_{31}\)</span>,<span class="arithmatex">\(E_{31}\)</span> 的目的就是在系数矩阵矩阵的(3,1)位置产生0.那么使用矩阵消去的思想就是:从A开始,使用E在主元下面产生0.(对于<code>Eq(1)</code>的A,第一个E是 <span class="arithmatex">\(E_{21}\)</span>).最后得到一个三角U.</strong></p>
<p>但注意,x没有改变,也就是说,消去之后,解是不会改变的.是系数矩阵改变了.当我们从Ax = b开始,乘以E.结果就是 <span class="arithmatex">\(EAx = Eb\)</span>.</p>
<blockquote>
<p><strong>注意</strong>:消去矩阵 <span class="arithmatex">\(E_{ij}\)</span> 是很好的例子,但是后面你不会再看到它.它们的作用是展示矩阵怎么作用在行上.通过一些消去步骤,我们会看到矩阵如何相乘.(E矩阵的顺序很重要).矩阵乘法和逆矩阵在E矩阵上也比较清晰.</p>
</blockquote>
<h2 id="32">3.2. 矩阵乘法</h2>
<p>首先问题是,两个矩阵怎么相乘?当我们的第一个矩阵是E: 把A和任何其他矩阵的2倍行1从行2减去.这个乘数是 <span class="arithmatex">\(\ell =2\)</span>
$$
E A = \left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \left[ \begin{array} { r r r } 2 &amp; 4 &amp; - 2 \ 4 &amp; 9 &amp; - 3 \ - 2 &amp; - 3 &amp; 7 \end{array} \right] = \left[ \begin{array} { r r r } 2 &amp; 4 &amp; - 2 \ 0 &amp; 1 &amp; 1 \ - 2 &amp; - 3 &amp; 7 \end{array} \right] \tag{2}
$$
这步骤,不会改变A的行1和行3.在EA当中,只有行2改变了.两倍行1被从行2减去.所以矩阵乘法达到了和消去一样的作用,而且新的方程组系统是:  <span class="arithmatex">\(EAx=Eb\)</span></p>
<p><span class="arithmatex">\(EAx\)</span> 是简单的,但涉及到一个微妙的思想.从 <span class="arithmatex">\(Ax = b\)</span> 开始,两边都乘以E,得到 <span class="arithmatex">\(E(Ax) = Eb\)</span>.有了矩阵乘法,这其实也是 <span class="arithmatex">\((EA)x = Eb\)</span>.注意这个转换过程,<strong>刚开始是 <code>E</code> 乘以 <code>Ax</code>,后面是 <code>EA</code> 乘以 <code>x</code> .但效果是一样的</strong>.所以括号是不需要的,我们直接写成 <span class="arithmatex">\(EAx\)</span></p>
<p>再然后，把上述思想可以扩展到有多列的矩阵C比如 <span class="arithmatex">\(C = [c_1,c_2,c_3]\)</span>.当乘以 <span class="arithmatex">\(EAC\)</span> 的时候,你可以先乘 <span class="arithmatex">\(AC\)</span> 或者 <span class="arithmatex">\(EA\)</span>.这就类似于结合律:<span class="arithmatex">\(3*(4*5) = (3*4)*5\)</span>.交换律 <span class="arithmatex">\(3*4 = 4*3\)</span> 看起来似乎更叫明显.但是 <span class="arithmatex">\(EA\)</span> 和 <span class="arithmatex">\(AE\)</span> 是<strong>不一样</strong>的.当E在右边,它<strong>作用在A的列上</strong>.</p>
<blockquote>
<ul>
<li>Associative law is true: <span class="arithmatex">\(A(BC) = (AB)C\)</span></li>
<li>Commutative law is <strong>false</strong>: 通常,<span class="arithmatex">\(AB \ne BA\)</span></li>
</ul>
</blockquote>
<p>矩阵乘法还有另外一项要求.假设B只有一列(就是b).那么EB的<strong>矩阵对矩阵</strong>的方式应该和Eb<strong>矩阵对向量</strong>的方式是相容的.更进一步,矩阵乘法EB应该可以<strong>一列列的乘</strong>.也就是说,如果B有多列 <span class="arithmatex">\(b_1,b_2,b_3\)</span>,那么EB的列就是 <span class="arithmatex">\(Eb_1,  Eb_2,  Eb_3\)</span></p>
<blockquote>
<p>矩阵乘法 : <span class="arithmatex">\(A B = A \left[ b _ { 1 } ，b _ { 2 }， b _ { 3 } \right] = \left[ A b _ { 1 }, A b _ { 2 }, A b _ { 3 } \right]\)</span></p>
</blockquote>
<p>比如Eq(2),把A的第三列乘以E,正确的得到E的第三列
$$
\left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \left[ \begin{array} { r } - 2 \ - 3 \ 7 \end{array} \right] = \left[ \begin{array} { r } - 2 \ 1 \ 7 \end{array} \right] \quad \color{orange} \text{E* (Column j of A) = column j of EA}
$$
注意这个性质是是针对列的,但消去却是应用到行上的.<code>&lt;#4&gt;</code>我们会学习乘积AB的每一项分别是什么.矩阵乘法的美丽之处在于,三种方式:行,列,整个矩阵,都是正确的</p>
<h2 id="33">3.3. 行交换矩阵</h2>
<blockquote>
<p>The Matrix <span class="arithmatex">\(P_{ij}\)</span>  for a row Exchange</p>
</blockquote>
<p>为了从行<code>i</code>减去行<code>j</code>,我们使用矩阵 <span class="arithmatex">\(E_{ij}\)</span>. 而我们也知道,当主元的位置是0的时候,就需要行交换.在主元位置下面,可能是不包含0的.换行以后,我们就有了一个新的主元,消去可以继续进行下去了.为了交换行,我们使用<strong>置换矩阵(permutation matrix)</strong>: <span class="arithmatex">\(P_{ij}\)</span>:</p>
<p>交换行2和行3的矩阵 <span class="arithmatex">\(P_{23}\)</span> 是什么样的呢?我们通过过交换单位矩阵 <code>I</code> 的行来找到这个矩阵
$$
P _ { 23 } = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 0 \end{array} \right]
$$
这是一个<strong>行交换矩阵(row exchange matrix)</strong>.乘以 <span class="arithmatex">\(P_{23}\)</span> 后会交换任何列向量的分量2和分量3,因此,也会交换任何矩阵的行2和行3</p>
<h2 id="34">3.4. 增广矩阵</h2>
<blockquote>
<p>The Augmented Matrix </p>
</blockquote>
<p>一开始,是一个方阵 <code>E</code> 乘以A,因为我们的消去需要这样,而且我们知道EA将会产生什么.下一步就是需要允许一个矩形矩阵的出现.这也是来自于初始的方程组,但是现在它包括了右边的b</p>
<blockquote>
<p><strong>关键概念</strong></p>
<hr />
<p>消去,在A和b上,都进行了相同的行操作.所以我们可以把 b 作为额外的一列来进行消去操作,也就是说,矩阵 A 多增加了一列b,从而增广了
$$
\text{增广矩阵}:\quad  \left[ \begin{array} { l l } A &amp; b \end{array} \right] = \left[ \begin{array} { r r r r } 2 &amp; 4 &amp; - 2 &amp; 2 \ 4 &amp; 9 &amp; - 3 &amp; 8 \ - 2 &amp; - 3 &amp; 7 &amp; 10 \end{array} \right]
$$
</p>
</blockquote>
<p>现在消去会作用在这个新矩阵的整行上.有了[A b]之后,原来方程当中的左边和右边的步骤一起发生.以<code>Eq(1)</code>的方程组为例
$$
\left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \left[ \begin{array} { r r r r } 2 &amp; 4 &amp; - 2 &amp; 2 \ 4 &amp; 9 &amp; - 3 &amp; 8 \ - 2 &amp; - 3 &amp; 7 &amp; 10 \end{array} \right] = \left[ \begin{array} { r r r r } 2 &amp; 4 &amp; - 2 &amp; 2 \ 0 &amp; 1 &amp; 1 &amp; 4 \ - 2 &amp; - 3 &amp; 7 &amp; 10 \end{array} \right]
$$</p>
<p>最右边新的第2行是 <code>0,1,1,4</code>.,也就代表了第2个方程就是 <span class="arithmatex">\(x_2+ x_3=4\)</span>.</p>
<p>注意矩阵的<strong>作用</strong>: A作用在x上产生b,E作用在A上产生EA,而整个消去步骤,其实就是一系列的行操作,这些行操作又可以通过矩阵乘法实现.如Eq(1)的矩阵当中,首先可以得到 <span class="arithmatex">\(E_{21} A\)</span> ,然后得到 <span class="arithmatex">\(E_{31} E_{21} A\)</span> ,最后 <span class="arithmatex">\(E_{32} E_{31} E_{21} A\)</span>  就是一个三角矩阵</p>
<p>现在,右边的向量被添加到A形成增广矩阵,最终结果还是一个三角系统，不变。</p>
<h2 id="35">3.5. 典型例题</h2>
<p><strong>1.</strong>  对于如下方程组，写出增广矩阵[A b],然后使用 <span class="arithmatex">\(E_{21},P_{32}\)</span> 进行操作，观察一下，如果一次性应用 <span class="arithmatex">\(P_{32}E_{21}\)</span> 到方程组，有什么效果
$$
\begin{array} { r } x + 2 y + 2 z = 1 \ 4 x + 8 y + 9 z = 3 \ 3 y + 2 z = 1 \end{array}
$$
解： 通过这一题，可以了解消去可以通过一个步骤完成
$$
\left[ \begin{array} { l l } A &amp; b \end{array} \right] = \left[ \begin{array} { l l l l } 1 &amp; 2 &amp; 2 &amp; 1 \ 4 &amp; 8 &amp; 9 &amp; 3 \ 0 &amp; 3 &amp; 2 &amp; 1 \end{array} \right] </p>
<p>\quad \text { 那么 } \quad E _ { 21 } \left[ \begin{array} { l l } A &amp; b \end{array} \right] = \left[ \begin{array} { l l l l } 1 &amp; 2 &amp; 2 &amp; 1 \ 0 &amp; 0 &amp; 1 &amp; - 1 \ 0 &amp; 3 &amp; 2 &amp; 1 \end{array} \right]
$$
行交换
$$
P _ { 32 } E _ { 21 } [ A \quad b ] = \left[ \begin{array} { r r r r } 1 &amp; 2 &amp; 2 &amp; 1 \ 0 &amp; 3 &amp; 2 &amp; 1 \ 0 &amp; 0 &amp; 1 &amp; - 1 \end{array} \right] \quad \text { 从而 } \quad \left[ \begin{array} { l } x \ y \ z \end{array} \right] = \left[ \begin{array} { r } 1 \ 1 \ - 1 \end{array} \right]
$$
所以，<span class="arithmatex">\(P_{32}E_{21}\)</span> 可以一次性完成:把 A 的 <span class="arithmatex">\(r_2 - 4 r_1\)</span> ，然后再交换 <span class="arithmatex">\(r_2,r_3\)</span>,从而完成整个消去步骤</p>
<hr />
<p><strong>2.</strong>  下面是矩阵乘法 AB 的2种方式</p>
<ol>
<li>A的行，乘以B的列</li>
<li><strong>A的列，乘以B的行</strong>
这种方式下，会产生2个矩阵，加起来得到AB</li>
</ol>
<p>最后总结一下，每种方式各需要多少次乘法
$$
\text{Both way:} \quad \quad A B = \left[ \begin{array} { l l } 3 &amp; 4 \ 1 &amp; 5 \ 2 &amp; 0 \end{array} \right] \left[ \begin{array} { l l } 2 &amp; 4 \ 1 &amp; 1 \end{array} \right] = \left[ \begin{array} { r r } 10 &amp; 16 \ 7 &amp; 9 \ 4 &amp; 8 \end{array} \right]
$$
解： 第一种方式，其实是<strong>向量的点乘</strong>：
$$
( \text { row } 1 ) \cdot ( \operatorname { column } 1 ) = \left[ \begin{array} { l l } 3 &amp; 4 \end{array} \right] \left[ \begin{array} { l } 2 \ 1 \end{array} \right] = 1 0 \quad \text { 是 AB 的} ( 1,1 ) \text {元素} \</p>
<p>( \text { row } 2 ) \cdot ( \operatorname { column } 1 ) = \left[ \begin{array} { l l } 1 &amp; 5 \end{array} \right] \left[ \begin{array} { l } 2 \ 1 \end{array} \right] = 7 \quad \text { 是 AB 的} ( 2,1 ) \text {元素}
$$
所以，AB一共有6个元素，每个元素，都是向量点乘产生的，而每次向量点乘，都需要2次乘法，所以一共需要<code>6*2 = 12</code>次乘法。对于 <span class="arithmatex">\([m,n] * [n,p]\)</span>的矩阵乘法，结果AB是<code>m*p</code> 个元素，而每个元素的产生，都是点乘，这个点乘需要 n 次乘法。所以 <span class="arithmatex">\([m,n] * [n,p]\)</span> 需要 <code>mnp</code> 次乘法</p>
<p>第二种方式如下
$$
A B = \left[ \begin{array} { l } 3 \ 1 \ 2 \end{array} \right] \left[ \begin{array} { l l } 2 &amp; 4 \end{array} \right] + \left[ \begin{array} { l } 4 \ 5 \ 0 \end{array} \right] \left[ \begin{array} { l l } 1 &amp; 1 \end{array} \right] = \left[ \begin{array} { r r } 6 &amp; 12 \ 2 &amp; 4 \ 4 &amp; 8 \end{array} \right] + \left[ \begin{array} { l l } 4 &amp; 4 \ 5 &amp; 5 \ 0 &amp; 0 \end{array} \right]
$$</p>
<blockquote>
<p>sp:注意这种方式，AB分解为：A的列乘以B的行，会产生中间矩阵。这时<code>&lt;#4&gt;</code> 里面的第四种方式</p>
</blockquote>
<h1 id="4">4. 矩阵操作法则</h1>
<blockquote>
<p>Rules for matrix Operations</p>
</blockquote>
<p>矩阵加法是简单的，这节主要关注矩阵乘法。</p>
<p>矩阵乘法 AB 需要满足: <strong>如果A有n列,那么B必须有n行.</strong> 当A是<code>3-2</code>,那么B可以是<code>2-1</code>(一个向量),<code>2-2</code>....<code>2-20</code>. <strong>B的每一列都被A乘</strong>.我们首先从点乘开始讲解矩阵乘法,然后回到列形式的方法:<strong>A 乘以B的列</strong>.最重要的一个法则就是,<strong>AB乘以C等于A乘以BC</strong>.挑战习题证明</p>
<p>假设A是<code>m-n</code>,而B是 <code>n-p</code>.那么AB就是<code>m-p</code>
$$
( m \times n ) ( n \times p ) = ( m \times p )
\</p>
<p>\left[ \begin{array} { c } </p>
<p>m \text { rows } \ n \text { columns } \end{array} \right] \left[ \begin{array} { c } n \text { rows } \ p \text { columns } \end{array} \right] = \left[ \begin{array} { c } m \text { rows } \ p \text { columns } \end{array} \right]
$$
一行乘以一列是一个极端的例子,也就是 <code>1-n</code>矩阵 乘以 <code>n-1</code> 矩阵,结果是一个<code>1-1</code>矩阵.AB的每一项都是点乘的值,比如,AB值的在左上角 <code>(1,1)</code> 项的值就是 <code>(A的第一行)*(B的第一列)</code>.矩阵相乘的每一项,就是取A的每一行和B的每一列的点乘.如下图</p>
<p><img alt="image-20210103011915756" src="../.assets/image-20210103011915756.png" /></p>
<p>计算一下,如果A,B都是 <code>n-n</code>的矩阵,那么AB的结果也是 <code>n-n</code> 的矩阵,它包含了 <span class="arithmatex">\(n^2\)</span> 个点乘的项.其中每一个项又包含了n个乘法,所以一共进行了 <span class="arithmatex">\(n^3\)</span> 个乘法.如果n = 100,那么我们进行了100万次乘法.</p>
<p>直到最近,数学家们也以为AB(<code>2-2</code>情况)需要 <span class="arithmatex">\(2^3=8\)</span> 次乘法.后面有人发现只需要7次,但是需要额外的加法.通过把 <code>n-n</code> 的矩阵分块成 <code>2-2</code> 的块矩阵,这个思想也可以用到大矩阵.效率已经不是 <span class="arithmatex">\(n^3\)</span>,而是下降到 <span class="arithmatex">\(n^{2.8}\)</span>,  而且这个指数一直在下降.目前最好的就是 <span class="arithmatex">\(n^{2.376}\)</span>  .但是这个算法很复杂,在科学计算还是使用常规的算法: $ n^2$ 个点乘, 每个点乘n个乘法.</p>
<p><strong>例1</strong> 假设A是 <code>[1 3]</code> 的行向量,而B是 <code>[3 1]</code>的列向量.那么AB是 <code>[1 1]</code> 的.而BA是 <code>[3 3]</code> 的</p>
<p>一个行乘以一个列是一个<strong>内部乘(inner product)</strong>-其实就是点乘的另外一个名字.一个列乘以一个行称为<strong>外部乘(outer product)</strong>.这些都是向量乘法的极端例子</p>
<h2 id="41-ab">4.1. A*B的行和列</h2>
<blockquote>
<p>Rows and columns of AB </p>
</blockquote>
<p>==从大的视图来看,A<em>B也相当于</em><em>A乘以了B的每一列,AB每一列都是A的列的组合</em><em>==.下面是矩阵乘法的列视图
$$
\color{orange} \text{A</em>B列视图：矩阵A乘以B的列：}\quad  A[b_1...b_p] = [Ab_1 ... Ab_p]
$$
==行视图是相反的,<strong>A的每一行乘以整个矩阵B，结果是AB的每一行都是B的行的组合:</strong>== 
$$
\color{orange} \text{AB行视图：矩阵A的每一行，乘以B：}\quad  \left[\begin{matrix} 
r_1  \
\vdots  \
r_m  \
\end{matrix} \right] B = \left[\begin{matrix} 
r_1B  \
\vdots  \
r_mB  \
\end{matrix} \right]
$$
我们在消去的过程 <span class="arithmatex">\(E*A\)</span> 中看到了行操作,我们在 <span class="arithmatex">\(A*x\)</span> 中看到了列操作.而 <strong>行-列视图(row-column picture)</strong> 则是有着行和列的点乘,不管你信不信,也有一个 <strong>列-行视图(column-row picture)</strong>: A的列<code>1...n</code> 分别乘以B的行 <code>1....n</code>,然后把中间结果加起来，得到的也是AB ,在例2当中,你会看到AB使用列乘以行的方式</p>
<h2 id="42">4.2. 矩阵操作律</h2>
<blockquote>
<p>The Laws for matrix operations</p>
</blockquote>
<p>矩阵的操作遵循6个规则,不遵循1个规则.这里的矩阵可以是正方形也可以是矩形的,涉及到A+B的是简单的,并且都是遵循的,</p>
<p><strong>3个加法法则</strong></p>
<p>$$
\begin{array} { r l r } A + B &amp; = B + A &amp; \text { (commutative law) } \ c ( A + B ) &amp; = c A + c B &amp; \text { (distributive law) } \ A + ( B + C ) &amp; = ( A + B ) + C &amp; \text { (associative law) } \end{array}
$$
<strong>3个乘法法则，和不成立的交换律</strong>
$$
\begin{aligned} </p>
<p>A B \neq B A &amp; \color{orange} \text  { (the commutative "law" is usually broken) } \ </p>
<p>C ( A + B ) = C A + C B &amp; \text { (distributive law from the left) } \ ( A + B ) C = A C + B C &amp; \text { (distributive law from the right) } \ A ( B C ) = ( A B ) C &amp; \text { (associative law for } A B C \text { ) (parentheses not needed) } </p>
<p>\end{aligned}
$$</p>
<p>当A,B不是正方形的时候.AB和BA是不同大小的.所以这两个矩阵明显不相等--就算乘法可以进行下去.对于正方形的矩阵,几乎所有的例子都可以得到,AB和BA是不一样的.</p>
<p>看一个特殊的例子,假设A = B = C = 正方形矩阵,那么  <span class="arithmatex">\((A*A^2) = (A^2  ∗A)\)</span>.最终结果都是 <span class="arithmatex">\(A^3\)</span>.矩阵的幂(matrix powers) <span class="arithmatex">\(A^p\)</span> 遵循和数字一样的规则
$$
A ^ { p } = A A A \cdots A ( p \text { factors } ) \quad \left( A ^ { p } \right) \left( A ^ { q } \right) = A ^ { p + q } \quad \left( A ^ { p } \right) ^ { q } = A ^ { p q }
$$
当p,q是0或者负数,这些规则也是成立的,但是要求矩阵A需要有一个 "-1的幂"--也就是逆矩阵 <span class="arithmatex">\(A^{−1}\)</span> .那么 <span class="arithmatex">\(A^0=I\)</span>. 对于一个数,<span class="arithmatex">\(a^{−1}=1/a\)</span>.对于一个矩阵,逆矩阵是 <span class="arithmatex">\(A^{−1}\)</span> (不是 <span class="arithmatex">\(I/A\)</span>,虽然这个写法在Matlab是允许的).每一个数a除了a = 0,都有一个<span class="arithmatex">\(a^{−1}\)</span> .但是矩阵A是否有逆矩阵是线性代数的一个中心问题.<code>&lt;#5&gt;</code> 节学习.</p>
<h2 id="43">4.3. 块矩阵和分块相乘</h2>
<blockquote>
<p>Block Matrices And block Multiplication </p>
</blockquote>
<p>矩阵可以被切成块:一些更小的矩阵.这是很常见的,下面是 <code>[4 6]</code> 的矩阵切成 <code>[2 2]</code> 的块,每一块都是<code>I</code>
$$
A = \left[ \begin{array} { l l | l l | l l } 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \ \hline 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \end{array} \right] = \left[ \begin{array} { l l l } I &amp; I &amp; I \ I &amp; I &amp; I \end{array} \right]
$$
如果B也是 <code>[4-6]</code> 矩阵,而且分块大小对应，那么你可以<strong>一块块的把A,B加起来.</strong> </p>
<p>其实我们已经遇见过分块矩阵了: 增广矩阵<code>[A b]</code>,有两块,大小不同.乘以一个消去矩阵得到<code>[EA Eb]</code>,当<strong>形状合适的时候,是可以分块相乘的</strong>. </p>
<blockquote>
<p><strong>Block multiplication</strong></p>
<hr />
<p>如果对A的<strong>列</strong>的切割，匹配B的<strong>行</strong>的切割(cuts between of A match the cus between rows of B)，那么AB的分块乘法是可行的：
$$
\left[ \begin{array} { l l } A _ { 11 } &amp; A _ { 12 } \ A _ { 21 } &amp; A _ { 22 } \end{array} \right] \left[ \begin{array} { l l } B _ { 11 } &amp; \cdots \ B _ { 21 } &amp; \cdots \end{array} \right] = \left[ \begin{array} { l l } A _ { 11 } B _ { 11 } + A _ { 12 } B _ { 21 } &amp; \cdots \ A _ { 21 } B _ { 11 } + A _ { 22 } B _ { 21 } &amp; \cdots \end{array} \right]</p>
<p>\tag{1}
$$
其实<code>Eq(1)</code> 的分块换成数字（其实<code>[1 1]</code>分块），也是成立的</p>
</blockquote>
<p>就算分块相乘,也必须小心,A在B前面,因为BA是不一样的.分块矩阵的<strong>主要目的</strong>就在于,可以更清楚的看到它们是怎么作用的.比如上面的A矩阵分块后,可以看到是多个 <code>I</code>。</p>
<p><strong>例2 分块的重要特殊例子</strong> 设A的分块是它的n列,B的分块是它的n行.那么分块相乘AB加起来得到 <strong>列乘行(columns times rows)</strong>
$$
\color{orange} \text{Columns times rows:} \quad
\color{black}</p>
<p>\left[\begin{matrix} 
| &amp;  &amp; |\
a_1 &amp; \dots &amp; a_n\
| &amp;  &amp; |\
\end{matrix} \right]</p>
<p>\left[\begin{matrix} 
- &amp; b_1 &amp; -\
&amp;  \vdots &amp; \
- &amp; b_n &amp; -\
\end{matrix} \right]</p>
<p>= \underbrace{[a_1b_1] + ... + [a_nb_n]  }_{\color{orange} \text{每一项都是一个[n n]矩阵}}</p>
<p>= [a_1b_1+...+a_nb_n]</p>
<p>\tag{2}
$$
这就是另外一种矩阵相乘的方式.和通常的行乘以列(row times columns)相乘的方式比较一下</p>
<ul>
<li>行 * 列： A的行1乘以B的列1得到AB的(1,1)元素.</li>
<li>列 * 行： A的列1乘以B的行1得到了一个<strong>完整的矩阵</strong>--而不仅仅是一个数字</li>
</ul>
<p>如下示例
$$
\left[ \begin{array} { l l } 1 &amp; 4 \ 1 &amp; 5 \end{array} \right] \left[ \begin{array} { l l } 3 &amp; 2 \ 1 &amp; 0 \end{array} \right] </p>
<p>= \left[ \begin{array} { l } 1 \ 1 \end{array} \right] \left[ \begin{array} { l l } 3 &amp; 2 \end{array} \right] + \left[ \begin{array} { l } 4 \ 5 \end{array} \right] \left[ \begin{array} { l l } 1 &amp; 0 \end{array} \right] </p>
<p>=</p>
<p>\left[ \begin{array} { l l } 3 &amp; 2 \ 3 &amp; 2 \end{array} \right] + 
\left[ \begin{array} { l l } 4 &amp; 0 \ 5 &amp; 0 \end{array} \right]  = </p>
<p>\left[ \begin{array} { l l } 7 &amp; 2 \ 8 &amp; 2 \end{array} \right] 
$$
列*行的形式,得到两个完整的矩阵,加起来得到的最后的结果.两种方法都是8个乘法,4个加法,只是不同的顺序运行而已</p>
<p><strong>例3 Elimination by blocks</strong></p>
<p>假设A的第一列是数字1,3,4.为了把3,4变为0,0,把主元所在的行乘以3和4,然后减去.这些行操作其实就是和消去矩阵 <span class="arithmatex">\(E_{21},E_{31}\)</span> 相乘:
$$
\text{once at a time:}\quad E _ { 21 } = \left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ - 3 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \text { and } E _ { 31 } = \left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ - 4 &amp; 0 &amp; 1 \end{array} \right]
$$
"分块思想"就是想要用一个矩阵E来完整全部的消去.这个矩阵会消去A的第一列在主元下面的数字，如
$$
E = \left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ - 3 &amp; 1 &amp; 0 \ - 4 &amp; 0 &amp; 1 \end{array} \right] \text { multiplies } \left[ \begin{array} { l l l } 1 &amp; x &amp; x \ 3 &amp; x &amp; x \ 4 &amp; x &amp; x \end{array} \right] \text { to give } E A = \left[ \begin{array} { l l l } 1 &amp; x &amp; x \ 0 &amp; x &amp; x \ 0 &amp; x &amp; x \end{array} \right]
$$
使用  <code>&lt;#5&gt;</code> 学习的逆矩阵,一个分块矩阵E可以对A进行一整列(块)的消去操作,假设A有4个分块A,B,C,D,看看E如何分块乘以A的结果:
$$
\color{orange} \text{BlocK elimination:} \quad \color{white}</p>
<p>\underbrace{\left[ \begin{array} { c | c } I &amp; 0 \ \hline - C A ^ { - 1 } &amp; I \end{array} \right] }_{M_1}</p>
<p>\underbrace{ \left[ \begin{array} { c | c } A &amp; B \ \hline C &amp; D \end{array} \right]}_{M_2}</p>
<p>= </p>
<p>\underbrace{\left[ \begin{array} { c | c } A &amp; B \ \hline 0 &amp; D - C A ^ { - 1 } B \end{array} \right]}_{M_3}
$$
我们分析一下上述过程（sp:以EA是E对A的行进行线性组合的方式，也就是行视图，参见本节<code>&lt;Lk1&gt; 方式3&gt;</code>）</p>
<ol>
<li>首先,<span class="arithmatex">\(M_1\)</span> 的第一行，组合 <span class="arithmatex">\(M_2\)</span> 的行，得到 <span class="arithmatex">\(M_3\)</span> 的第一行 <code>[A B]</code>.</li>
<li>重点来了。分块矩阵 <span class="arithmatex">\(M_1\)</span> 第2行 组合 <span class="arithmatex">\(M_2\)</span> 的行，细分2步：</li>
<li><span class="arithmatex">\(CA^{−1}\)</span>  (以前没分块之前，是c / a) 乘以 <span class="arithmatex">\(M_2\)</span> 行1，得到 <span class="arithmatex">\([-C,-CA^{-1}B]\)</span>.</li>
<li><code>I</code> 乘以 <span class="arithmatex">\(M_2\)</span> 行2，得到 <span class="arithmatex">\([C,D]\)</span></li>
<li>1,2步骤相加，得到 <span class="arithmatex">\(M_3\)</span> 的第2行是 <span class="arithmatex">\([0,D- CA^{−1} B]\)</span>. </li>
</ol>
<p>以上过程这其实就是普通的消去,只是写成块形式.最后的块 <span class="arithmatex">\(S =  D - CA^{−1}  B\)</span>,其实就像是 <span class="arithmatex">\(d - cb/a\)</span>.,这部分叫做<strong>舒尔补(Schur complement)</strong>.</p>
<blockquote>
<p>其实这里意思是,分块消去和普通的消去矩阵<code>E</code>是没什么区别的.假设我们把ABCD都看作是数字,那么第一个主元就是A,我们想要消去C,乘数就是-C/A,也就是 <span class="arithmatex">\(E_{21}=−C/A\)</span>  .但是分块矩阵A不是数字,而是一个矩阵,所以应该是 <span class="arithmatex">\(-CA^{−1}\)</span>.也是一个行消去.参见 <strong>习题4</strong> 例子！</p>
</blockquote>
<h2 id="44-lk1">4.4. Lk1:矩阵乘法总结</h2>
<p>总结一下,对于矩阵乘法AB = C.</p>
<ol>
<li>
<p><strong>点乘</strong>： C的每一个元素，都是 <span class="arithmatex">\(A的行  \cdot B的列\)</span>,这其实就是 <strong>行-列方式(row column picture)</strong></p>
</li>
<li>
<p>==<strong>列方式(列空间)</strong> ：C的每一列,都是A的列的线性组合==,举例来说： <code>C的列1 = B的列1对A的全部列做线性组合</code></p>
</li>
<li>
<p>==<strong>行方式(行空间)</strong>：C的每一行,都是B的行的线性组合==.举例来说： <code>C的行1 = A的行1对B的全部行做线性组合</code></p>
</li>
<li>
<p>==<strong>列行方式(column row picture)</strong>:  A的列<em>B的行，每个列行相乘，产生的中间矩阵都是和最终结果</em><em>同样维度的</em><em>，最终把所有中间矩阵加起来，得到最后的结果。==如果把</em><em>其中一次</em>*行列想成拎出来看：
$$
\left[\begin{matrix} 
|  \
c_n  \
|  \
\end{matrix} \right] \left[\begin{matrix} </p>
</li>
<li>
<p>&amp; r_n &amp; - \
\end{matrix} \right] = M
$$</p>
</li>
<li>
<p>从列方式来看，M的每一列，都是 <span class="arithmatex">\(c_n\)</span> 的倍数</p>
</li>
<li>从行方式来看，M的每一行，都是 <span class="arithmatex">\(r_n\)</span> 的倍数</li>
</ol>
<p>上面4种方式，其实都可以解释为分块乘法！注意AB分块乘法当中，<strong>A的==列==的切割和B的==行==的切割对应</strong>，方式4特别明显</p>
<h2 id="45">4.5. 关键概念</h2>
<ol>
<li>一个 <code>[m n]</code> 矩阵乘以一个 <code>[n p]</code> 矩阵使用了 <code>mnp</code> 次乘法</li>
<li>A(BC)等于(AB)C,很重要!</li>
<li>当矩阵之间的分块是匹配的时候,分块乘法是被允许的</li>
<li>分块乘法产生了舒尔补： <span class="arithmatex">\(D - CA^{−1} B\)</span>.</li>
</ol>
<h2 id="46">4.6. 典型例题</h2>
<p><strong>1.</strong> 矩阵乘法是很特别的,为了说明清楚,只以小矩阵举例子. 有一个非常特别的矩阵家族,帕斯卡(Pascal)矩阵,各种大小都有,实际上它们都是有实际意义的,4-4的已经足够理解它们神奇的模式了。下面是一个下三角帕斯卡矩阵L,它的元素来自于帕斯卡<strong>三角形(Pascal's triangle)</strong>,把L乘以 1's 向量, 和  幂 向量:
$$
\left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 1 &amp; 1 &amp; &amp; \ 1 &amp; 2 &amp; 1 &amp; \ 1 &amp; 3 &amp; 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l } 1 \ 1 \ 1 \ 1 \end{array} \right] = \left[ \begin{array} { l } 1 \ 2 \ 4 \ 8 \end{array} \right] </p>
<p>,\qquad </p>
<p>\left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 1 &amp; 1 &amp; &amp; \ 1 &amp; 2 &amp; 1 &amp; \ 1 &amp; 3 &amp; 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l } 1 \ x \ x ^ { 2 } \ x ^ { 3 } \end{array} \right] = \left[ \begin{array} { c } 1 \ 1 + x \ ( 1 + x ) ^ { 2 } \ ( 1 + x ) ^ { 3 } \end{array} \right]
$$
L的每一行可以得到下一行:把每一个元素和它左边元素加起来得到这个元素下面的元素,符号表示就是:<span class="arithmatex">\(\ell_{ij} + \ell_{i,j-1} = \ell_{i+1,j}\)</span>，所以L的下一行是 <code>(1,4,6,4,1)</code>.</p>
<p>乘以 1's 向量，和把每一行加起来是一样的(sp:左上第1个等式), 为了得到2的幂.把L和x的幂相乘,你可以看到,L的每一项都说是二项式系数,这些系数对赌博爱好者来说是很重要的:
$$
1 + 2 x + 1 x ^ { 2 } = ( 1 + x ) ^ { 2 } \quad 1 + 3 x + 3 x ^ { 2 } + 1 x ^ { 3 } = ( 1 + x ) ^ { 3 }
$$
数字"3"计算的是,抛掷一个硬币3次,得到正面 1次和反面 2次的方法: <code>HTT ,THT ,TTH</code>.另外一个3是得到正面2次反面一次的方法 <code>HHT ,HTH ,THH</code>. 这些都是 <code>从i中选择j =  i次硬币抛掷中出现j次正面数字</code>.这些数字恰好就是<span class="arithmatex">\(\ell_{ij}\)</span>.如果我们以0开始计数L的行和列，那么
$$
\ell _ { i j } = \left( \begin{array} { l } i \ j \end{array} \right) = i \text { choose } j = \frac { i ! } { j ! ( i - j ) ! } \quad \left( \begin{array} { l } 4 \ 2 \end{array} \right) = \frac { 4 ! } { 2 ! 2 ! } = \frac { 24 } { ( 2 ) ( 2 ) } = 6
$$
也就说说,从4张Ace当中有6种方式选出2张Ace.我们还会继续遇到帕斯卡矩阵的,下面是问题:</p>
<ol>
<li><span class="arithmatex">\(H = L^2\)</span> 是一个 hypercube matrix,计算出它</li>
<li>将H乘以 1 向量和幂向量</li>
<li>H最后一行是 <code>8,12,6,1</code>,而一个立方体有8个角，12条边，6个面，一个立方体。那么H的下一行会告诉你，4D超立方体是什么样子的？(sp:这其实是<code>&lt;EX-01&gt; 习题4</code> 的答案）</li>
</ol>
<p>解: 首先，计算 H 
$$
\left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 1 &amp; 1 &amp; &amp; \ 1 &amp; 2 &amp; 1 &amp; \ 1 &amp; 3 &amp; 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 1 &amp; 1 &amp; &amp; \ 1 &amp; 2 &amp; 1 &amp; \ 1 &amp; 3 &amp; 3 &amp; 1 \end{array} \right] = \left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 2 &amp; 1 &amp; &amp; \ 4 &amp; 4 &amp; 1 &amp; \ 8 &amp; 12 &amp; 6 &amp; 1 \end{array} \right] = H
$$
现在将H乘以ones和 powers
$$
\left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 2 &amp; 1 &amp; &amp; \ 4 &amp; 4 &amp; 1 &amp; \ 8 &amp; 12 &amp; 6 &amp; 1 \end{array} \right] \left[ \begin{array} { l } 1 \ 1 \ 1 \ 1 \end{array} \right] = \left[ \begin{array} { c } 1 \ 3 \ 9 \ 27 \end{array} \right]，\qquad </p>
<p>\left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 2 &amp; 1 &amp; &amp; \ 4 &amp; 4 &amp; 1 &amp; \ 8 &amp; 12 &amp; 6 &amp; 1 \end{array} \right] \left[ \begin{array} { l } 1 \ x \ x ^ { 2 } \ x ^ { 3 } \end{array} \right] = \left[ \begin{array} { c } 1 \ 2 + x \ ( 2 + x ) ^ { 2 } \ ( 2 + x ) ^ { 3 } \end{array} \right]
$$
如果x = 1,我们得到3的幂, 如果x  =  0,我们得到的是2的幂.L产生的是 <span class="arithmatex">\(1 + x\)</span>的指数,再次乘以L得到的是 <span class="arithmatex">\(2+x\)</span> 的指数</p>
<p>那么H是怎么计算出多面体的边,顶点和面的呢? 一个2D的正方形有4个顶点,4条边,1个面,如果一次增加一维：<strong>连接2个正方形得到3D立方体，连接2个3D立方体得到4D超立方体</strong>。3D立方体有8个顶点,12条边，6个面。因为</p>
<ul>
<li>定点就是2个2D正方体的顶点和：4+4 = 8</li>
<li>2个被连接组成立方体的正方形各有4个边,连接它们的边有4条.共12条</li>
<li>3D立方体有6个面,每个正方形各有1个,连接它们又产生了4个.</li>
</ul>
<p>行 <code>8,12,6,1</code> 可以得到下面1行 <code>16,32,24,8,1</code>. 规则是: <span class="arithmatex">\(2h_{ij}   +  h_{i,j−1}   =  h_{i+1,j}\)</span>.这时候你可以发现4维下的规律了吗?</p>
<ul>
<li>4D超立方体有16个顶点，也就是3D立方体定点之和: <code>8+8=16</code></li>
<li>边的数目: 每个3D立方体有12条边,还有8条边需要用来连接2个立方体(sp:因为有8个顶点),所有 <span class="arithmatex">\(12*2 + 8 = 32\)</span>条边 </li>
<li>面数呢,首先每个3D立方体有6个面,而<strong>连接边</strong>又会得到12个面,所以总的面数就是 <span class="arithmatex">\(6*2+12=24\)</span>.（sp:只能想到连接产生的10个啊？不要想象四维,一般都是错的，注意面是因为边的连接产生的，也就是书本长说的 <code>connecting pair of edges</code>,2个3D立方体的12条边相连，每2条边之间可以产生1个面，而且是循环的，如3D情况下4条连接边产生了4个面，所以新产生了12个面）</li>
<li>而且,每个3D立方体是一个盒子(box),<strong>连接面</strong>会产生另外6个盒子,共有8个盒子（sp:注意，这里是连接面，因为有12个新的面，）</li>
<li>最后,是一个超立方体</li>
</ul>
<blockquote>
<p>sp:上述思想是这样的</p>
<ol>
<li>顶点的数目直接加起来可以得到，上面就是 8+8=16</li>
<li>边的数目是连接<strong>顶点对(pair of corners)</strong> 得到，所以上述得到8个新边</li>
<li>面的数目通过连接<strong>边对(pair of edges)</strong> 得到，2个被连接的3D立方体12条边，12对边对，从而有新的12个面</li>
<li>而盒子的数目通过<strong>连接面对(pair of faces)</strong> 得到，2个被连接的3D立方体原来有6个面，所以会产生6个盒子，一共2+6=8</li>
</ol>
</blockquote>
<hr />
<p><strong>2.</strong> 对于下面的矩阵,什么时候AB = BA?什么时候BC = CB? 什么时候A乘以BC等于AB乘以C?给出 <code>p,  q,  r,  z,1</code> 需要满足的条件.如果 <code>p,q,r,z</code>和元素 <code>1</code> (变成<code>I</code>) 是4-4快矩阵而不是数字,答案有变化吗?
$$
A = \left[ \begin{array} { l l } p &amp; 0 \ q &amp; r \end{array} \right] \quad B = \left[ \begin{array} { l l } 1 &amp; 1 \ 0 &amp; 1 \end{array} \right] \quad C = \left[ \begin{array} { l l } 0 &amp; z \ 0 &amp; 0 \end{array} \right]
$$
解:  首先，A乘以BC总是等于AB乘以C，这其实就是结合律。</p>
<p>现在我们计算一下AB和BA:
$$
\text{通常 }AB \ne BA:\qquad  A B = \left[ \begin{array} { c c } p &amp; p \ q &amp; q + r \end{array} \right] \quad B A = \left[ \begin{array} { c c } p + q &amp; r \ q &amp; r \end{array} \right]</p>
<p>\[6ex]</p>
<p>\text{有时候 }BC = CB \qquad B C = \left[ \begin{array} { l l } 0 &amp; z \ 0 &amp; 0 \end{array} \right] \quad C B = \left[ \begin{array} { l l } 0 &amp; z \ 0 &amp; 0 \end{array} \right]
$$
上式当中，B，C只是恰好满足了交换律。B和C只是一个例外而已.当 <code>p,  q,  r,  Z</code> 是4-4分块,1 变成 <code>I</code>,答案也是一样的</p>
<hr />
<p><strong>3.</strong> 一个<strong>有向图(directed  graph)</strong>.以n个节点开始. n-n的邻接矩阵(adjacency  matrix),当一条边从节点 <code>i</code> 出发到节点 <code>j</code> 时,<span class="arithmatex">\(a_{ij}   =  1\)</span> ; 如果没有这条边,那么 <span class="arithmatex">\(a_{ij} = 0\)</span>.</p>
<p><img alt="image-20210105152436671" src="../.assets/image-20210105152436671.png" /></p>
<p><span class="arithmatex">\(A^2\)</span> 的 <code>(i,j)</code> 元素是 <span class="arithmatex">\(\sum a_{ik}a_{kj} = a_{i1} a_{1j}+…+ a_{in} a_{nj}\)</span>. 为什么这个和,可以计算出从 <code>i</code> 节点到 <code>j</code> 节点的的两步路径?如下
$$
\left[ \begin{array} { l l } 1 &amp; 1 \ 1 &amp; 0 \end{array} \right] ^ { 2 } = \left[ \begin{array} { l l } 2 &amp; 1 \ 1 &amp; 1 \end{array} \right]</p>
<p>\quad \color{orange} \text{2步路径:} \quad </p>
<p>\left[\begin{matrix} 
1\rightarrow 2 \rightarrow 1,   1 \rightarrow 1 \rightarrow 1 &amp; 
1\rightarrow 1 \rightarrow 2 \
2\rightarrow 1 \rightarrow 1 &amp;  2\rightarrow 1 \rightarrow 2\
\end{matrix} \right]
$$
<span class="arithmatex">\(A^k\)</span> 的 <code>(i,j)</code> 元素计算的就是k步路径。 计算出每一对节点的3步路径,并且和 <span class="arithmatex">\(A^3\)</span> 比较.</p>
<p>解:如果有一条从节点 <code>i</code> 到节点 <code>k</code> ,并且有一条从节点 <code>k</code> 到节点 <code>j</code> 的路径,那么 <span class="arithmatex">\(a_{ik} a_{kj}\)</span> 是1. 这是一个两步路径. 而如果没有从 <code>i</code> 到 <code>k</code> 的路径,或者没有从 <code>k</code> 到 <code>j</code> 的路径, <span class="arithmatex">\(a_{ik} a_{kj}\)</span> 是0.所以 <span class="arithmatex">\(a_{ik} a_{kj}\)</span> 的和是从 <code>i</code> 点离开到达 <code>j</code> 点的2步路径之和.矩阵乘法刚好等于这个数目.</p>
<p>3步路径是由 <span class="arithmatex">\(A ^ { 3 } = \left[ \begin{array} { l l } 3 &amp; 2 \\ 2 &amp; 1 \end{array} \right]\)</span> 计算的 ,请自己验证一下.</p>
<p>看一下k步路径：<span class="arithmatex">\(A^k\)</span> 包含Fibonacci 数字 <code>0,  1,  1,2,3,5,8,13,  ...</code>  这些知识在<code>&lt;01-06 #2&gt;</code>.把A乘以 <span class="arithmatex">\(A^k\)</span>  涉及到Fibonacci's规则 $F_{k+2}   =  F_{k+1}   +  F_k $  (比如  13=8+5):从节点1到节点1有13条6步路径,但是我也不能全部找到!
$$
( A ) \left( A ^ { k } \right) = \left[ \begin{array} { l l } 1 &amp; 1 \ 1 &amp; 0 \end{array} \right] \left[ \begin{array} { l l } F _ { k + 1 } &amp; F _ { k } \ F _ { k } &amp; F _ { k - 1 } \end{array} \right] = \left[ \begin{array} { l l } F _ { k + 2 } &amp; F _ { k + 1 } \ F _ { k + 1 } &amp; F _ { k } \end{array} \right] = A ^ { k + 1 }
$$
<span class="arithmatex">\(A^k\)</span> 也可以计算单词,一个类似 <code>1-1-2-1</code> 的路径其实就是对应单词aaba,字母b不能出现重复是因为没因为没有从2-2的边.<span class="arithmatex">\(A^k\)</span>  的 <code>i,j</code> 元素计算的是长度是 <code>k+1</code>,首字母是第 <code>i</code> 个字母而尾字母是第 <code>j</code> 个字母的单词</p>
<h1 id="5">5. 逆矩阵</h1>
<blockquote>
<p>innverse matrix</p>
</blockquote>
<h2 id="51">5.1. 导入</h2>
<blockquote>
<p>来自视频</p>
</blockquote>
<p>现在看一个2-2的矩阵 <span class="arithmatex">\(A=\left[\begin{matrix} 1 &amp; 3 \\2 &amp; 6 \\\end{matrix} \right]\)</span>, 如果知道行列式的知识,可以知道它行列式是0,所以没有逆.但也可用前面学的知识判断一下.假设 <span class="arithmatex">\(AM = I\)</span>,那么 <code>I</code> 的列都是来自以A的列的线性组合.<code>I</code> 的第一列是(1,0),不可能是A的列(1,2),(3,6)的线性组合,因为 <code>(1,2),(3,6)</code> 在同一条直线上,它们的线性组合也肯定是在这一条直线上的,而<code>(1,0)</code>却不是在这条直线上的.这就是不可逆的列图像了.</p>
<p>还有一个更重要的解释.如果存在非0向量x,使得 <code>Ax  = 0</code>,那么矩阵没有逆.对于这个A,x是多少呢?这个x是 <code>(3,-1)</code>.(sp:因为这样表明列不是线性独立的,存在列的非0线性组合可以得到0向量).A的列是共线的,有一些列毫无贡献.所以不可逆.结论就是,<strong>不可逆(奇异)矩阵,列的线性组合(乘以非0x)可以得到0.</strong></p>
<p>把矩阵变换成 <span class="arithmatex">\(A = \left[\begin{matrix} 1 &amp; 3 \\2 &amp; 7 \\\end{matrix} \right]\)</span> ,那么c1和c2是不共线的向量,它们的组合可以得到任意的向量.现在我们要找到它的逆
$$
\left[ \begin{array} { l l } 1 &amp; 3 \ 2 &amp; 7 \end{array} \right] \left[ \begin{array} { l l } a &amp; c \ b &amp; d \end{array} \right] = \left[ \begin{array} { l l } 1 &amp; 0 \ 0 &amp; 1 \end{array} \right]
$$
A乘以(a,b)得到(1,0),乘以(c,d)得到(0,1),其实是<strong>两组</strong>2个方程2个未知数的方程组.所以<strong>求逆矩阵和解方程组其实是一回事</strong>.只是有多个方程组而已.A乘以A逆的第 <code>j</code> 列,得到 <code>I</code> 的第 <code>j</code> 列.系数矩阵A是相同的,不同的只是右侧的b.</p>
<p>求逆矩阵的方法就是GJ方法. 以上面的例子,消元增广矩阵 <span class="arithmatex">\(\left[ \begin{array} { l l l l } 1 &amp; 3 &amp; 1 &amp; 0 \\ 2 &amp; 7 &amp; 0 &amp; 1 \end{array} \right]\)</span>,当 <span class="arithmatex">\(\left[\begin{matrix} 1 &amp; 3 \\2 &amp; 7 \\\end{matrix} \right]\)</span> 部分变为单位矩阵 <code>I</code> 的时候,<span class="arithmatex">\(\left[\begin{matrix} 1 &amp; 0 \\0 &amp; 1 \\\end{matrix} \right]\)</span>部分就会变成逆矩阵.
$$
\left[ \begin{array} { l l l l } 1 &amp; 3 &amp; 1 &amp; 0 \ 2 &amp; 7 &amp; 0 &amp; 1 \end{array} \right] </p>
<p>\overset{1:左侧化为U}{\Longrightarrow}</p>
<p>\left[ \begin{array} { l l l l } 1 &amp; 3 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; -2 &amp; 1 \end{array} \right]</p>
<p>\overset{2:r_1 - 3r_2}{\Longrightarrow}</p>
<p>\left[ \begin{array} { l l l l } 1 &amp; 0 &amp; -7 &amp; -3 \ 0 &amp;1 &amp; -2 &amp; -1 \end{array} \right]
$$
在第1步,左边的两列已经是U了,但还可以继续化简！使得左侧变成单位矩阵,这时候右侧就是A的逆矩阵了</p>
<p>那么为什么 <code>[A I]</code> 经过GJ方法后可以化为 <span class="arithmatex">\([I\quad A^{−1}]\)</span> 呢?. 回忆一下消去矩阵E.很多个E相乘A最终可以化为一个E乘以A.那么
$$
E[A,I] = [I,?]
$$
<span class="arithmatex">\(EA = I\)</span>,那么 <code>E</code> 就是 <span class="arithmatex">\(A^{−1}\)</span> ,而 <span class="arithmatex">\(A^{−1} I= A^{−1}\)</span>.这就是GJ方法求解逆矩阵的思想</p>
<hr />
<p><strong>方阵可以求逆矩阵,而且如果逆存在,左逆=右逆</strong> .假设A是一个方阵,我们想要找到一个<strong>相同大小</strong>的逆矩阵<span class="arithmatex">\(A^{−1}\)</span>, 其乘以A结果就是单位矩阵<code>I</code>.A做了什么,<span class="arithmatex">\(A^{−1}\)</span> 就反着做什么,它们之间的作用相互抵消.它们的乘积是单位矩阵<code>I</code>,而 <code>I</code>对向量相当于是无作用的,所以 <span class="arithmatex">\(A^{−1} Ax = x\)</span>.<strong>但是 <span class="arithmatex">\(A^{−1}\)</span> 可能不存在</strong></p>
<p>将 <span class="arithmatex">\(A^{−1}\)</span> 乘以 <code>Ax= b</code> 得到 <span class="arithmatex">\(A^{−1} Ax = A^{−1} b\)</span>.也就是 <span class="arithmatex">\(x  = A^{−1} b\)</span>.乘积 <span class="arithmatex">\(A^{−1} A\)</span> 就像是先乘以一个数字,然后再除以同一个数字.一个数字当它不为0的时候有它的"逆数(inverse)"--但是矩阵就比较复杂和有趣了.矩阵 <span class="arithmatex">\(A^{−1}\)</span> 叫做A的逆(A Inverse)</p>
<blockquote>
<p><strong>Definition</strong></p>
<hr />
<p>如果对于矩阵A,存在矩阵 <span class="arithmatex">\(A^{-1}\)</span> 满足下面等式,那么A称为<strong>可逆的(inverrible)</strong>
$$
A^{-1}A = I \quad \text{and} \quad AA^{-1} = I
$$</p>
</blockquote>
<p><strong>不是所有的矩阵都可逆</strong>.对一个方矩第一个问题是:A可逆吗?我们不是一开始就计算<span class="arithmatex">\(A^{-1}\)</span>.在多数问题当中,我们甚至<strong>从不需要计算出来</strong>!下面是对于 <span class="arithmatex">\(A^{-1}\)</span> 的6个提醒:</p>
<ol>
<li>
<p><strong>当且仅当</strong>消去产生了n个主元,逆矩阵存在(允许行交换),<code>&lt;#5.4&gt;</code> 证明。消去不用显式使用 <span class="arithmatex">\(A^{-1}\)</span>,即可求解 Ax = b</p>
</li>
<li>
<p>矩阵A不可能有两个逆矩阵.假设 <code>BA = I</code>.而且 <code>AC  =I</code>.那么B = C,这是因为:
$$
B(AC) = (BA)C \quad \Rightarrow \quad BI = IC \quad \Rightarrow B=C \tag{2}
$$
这就展示了,==左逆B和右逆C必须是同一个矩阵==</p>
</li>
<li>
<p>如果A是可逆的,那么Ax = b的<strong>唯一</strong>的解就 <span class="arithmatex">\(是x = A^{-1} b\)</span></p>
</li>
<li>
<p>(重要)假设存在一个非0向量 x 满足 Ax = 0,那么A不可逆.<strong>没有矩阵,能将0转换回x</strong>!</p>
</li>
<li>
<p>当且仅当ad - bc 不为0,一个 <code>[2 2]</code> 的矩阵是可逆的
$$
\text{[2,2] 矩阵}  : \left[ \begin{array} { l l } a &amp; b \ c &amp; d \end{array} \right] ^ { - 1 } = \frac { 1 } { a d - b c } \left[ \begin{array} { r r } d &amp; - b \ - c &amp; a \end{array} \right] \tag{3}
$$
数 <code>ad - bc</code> 是A的行列式.当<strong>一个矩阵的行列式不为0的时候</strong>,是可逆的(<code>&lt;01-05&gt;</code>).但我们<strong>通常先进行n个主元的测试</strong>,而不是行列式测试</p>
</li>
<li>
<p>一个对角线矩阵(diagonal matrix),在对角线上的元素都不为0的时候,是可逆的
$$
A = \left[ \begin{array} { l l l } d _ { 1 } &amp; &amp; \ &amp; \ddots \ &amp; &amp; d _ { n } \end{array} \right] \quad \text { then } A ^ { - 1 } = \left[ \begin{array} { l l l } 1 / d _ { 1 } \ &amp; \ddots \ &amp; &amp; 1 / d _ { n } \end{array} \right]
$$</p>
</li>
<li></li>
</ol>
<blockquote>
<p>第5点证明(来自习题）从下面等式可以看出来：
$$
\left[ \begin{array} { l l } a &amp; b \ c &amp; d \end{array} \right] \left[ \begin{array} { r r } d &amp; - b \ - c &amp; a \end{array} \right] = \left[ \begin{array} { c c } a d - b c &amp; 0 \ 0 &amp; a d - b c \end{array} \right]
$$
</p>
</blockquote>
<p><strong>例1</strong> 矩阵 <span class="arithmatex">\(\left[\begin{matrix} 1 &amp; 2 \\1 &amp; 2 \\\end{matrix} \right]\)</span> 是不可逆的.因为</p>
<ul>
<li>对于提醒5,测试是失败的</li>
<li>提醒4测试也是失败的,因为当x = (2,-1),Ax = 0</li>
<li>对于测试1,测试是失败的,因为没有2个主元,经过消去之后第2行都是0</li>
</ul>
<h2 id="52-ab">5.2. 乘积AB的逆矩阵</h2>
<blockquote>
<p>The Inverse of a product AB </p>
</blockquote>
<p>对于两个非0的数字a,b,和a+b可能是可逆的,也可能不是.比如 <span class="arithmatex">\(a = 3,b = -3\)</span>,逆数分别是 <code>1/3,-1/3</code>,而和是0,不可逆.但是 <span class="arithmatex">\(ab = -9\)</span>,逆数是 <code>-1/9</code>,也就是<code>1/3 * (-1/3)</code></p>
<p>对于两个矩阵A,B,情况是类似的.对于A+B的逆矩阵是很难确定的,但是只要A,B分别是可逆的(当然形状需要一样),那么AB就是可逆的.重要的一点是, <span class="arithmatex">\(A^{-1},B^{-1}\)</span> 以<strong>相反顺序出现</strong></p>
<p>如果A,B是可逆的,那么AB也是可逆的,AB的逆矩阵是:
$$
(AB)^{-1}= B^{-1}A^{-1} \tag{4}
$$
为了看看为什么顺序反了,我们将AB乘以<span class="arithmatex">\(B^{−1} A^{−1}\)</span> 看看:
$$
AB(B^{−1} A^{−1}) = AIA^{-1} = AA^{-1} = I
$$
这其实就是展示了一个数学的基本规则:逆以相反顺序出现(Inverses come in reverse order).再多的矩阵,也是反着来的
$$
\text{Reverse Order: } \quad (ABC)^{-1} = C^{-1}B^{-1} A^{-1} \tag{5}
$$</p>
<p><strong>例2 消去矩阵的逆矩阵</strong>.  如果 E 把5倍 r1 从 r2 减去,那么 <span class="arithmatex">\(E^{−1}\)</span> 把5倍 r1 加到 r2 :
$$
E = \left[ \begin{array} { r r r } 1 &amp; 0 &amp; 0 \ - 5 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \text { and } E ^ { - 1 } = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 5 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right]
$$
不管我们是先加然后再减( <span class="arithmatex">\(EE^{−1}\)</span> ),或者减再加( <span class="arithmatex">\(E^{−1} E\)</span> ),我们都回到了原点一样</p>
<p><strong>例3</strong> 假设F从 <code>r3</code> 减去了 <code>4r2</code>,那么 <span class="arithmatex">\(F^{−1}\)</span> 把它加回来:
$$
F = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; - 4 &amp; 1 \end{array} \right] \quad \text { and } \quad F ^ { - 1 } = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 4 &amp; 1 \end{array} \right]  \tag{6}
$$
现在,将F乘以例1的E,得到 <code>FE</code> .也把 <span class="arithmatex">\(E^{−1}\)</span>  乘以 <span class="arithmatex">\(F^{−1}\)</span> 得到 <span class="arithmatex">\((FE)^{−1}\)</span>.注意顺序:<span class="arithmatex">\((FE)^{−1}  = E^{−1} F^{−1}\)</span>.
$$
F E = \left[ \begin{array} { c c c } 1 &amp; 0 &amp; 0 \ - 5 &amp; 1 &amp; 0 \ 20 &amp; - 4 &amp; 1 \end{array} \right] \quad \text { 的逆矩阵是 } \quad E ^ { - 1 } F ^ { - 1 } = \left[ \begin{array} { c c c } 1 &amp; 0 &amp; 0 \ 5 &amp; 1 &amp; 0 \ 0 &amp; 4 &amp; 1 \end{array} \right]
$$
这真是很美丽.乘积 <code>FE</code> 包含了 <code>20</code> 这个值,但是逆矩阵并没有.E将5倍 <code>r1</code> 从 <code>r2</code> 减去.然后F将新的 <code>r2</code>(由E改变)的4倍从 <code>r3</code> 减去.在这个顺序之下,<code>r3</code> 察觉到了 <code>r1</code> 的影响.</p>
<p>在 <span class="arithmatex">\(E^{−1} F^{−1}\)</span> 的顺序当中.这样的影响是不存在的.首先 <span class="arithmatex">\(F^{−1}\)</span> 把4倍 <code>r2</code> 加到 <code>r3</code>,然后,<span class="arithmatex">\(E^{−1}\)</span> 把5倍 <code>r1</code> 行1加到 <code>r2</code>.因为 <code>r3</code> 不再改变,所以没有 <code>20</code>.顺序 <span class="arithmatex">\(E^{−1} F^{−1}\)</span> 下,<code>r3</code> 不会察觉到 <code>r1</code> 的影响,<strong><span class="arithmatex">\(E^{−1} F^{−1}\)</span> 更快,乘数 <code>5,4</code> 直接放到对角线元素1下面</strong></p>
<p>特殊的乘法 <span class="arithmatex">\(E^{−1} F^{−1},E^{−1} F^{−1}G^{-1}\)</span> 在<code>&lt;#6&gt;</code>很有用,我们会再次解释一下.在这一节我们的目标是 <span class="arithmatex">\(A^{−1}\)</span>,我们想要有一些方法来计算它.如下</p>
<h2 id="53-a1">5.3. 通过高斯-约当消去计算 <span class="arithmatex">\(A^{−1}\)</span></h2>
<blockquote>
<p>Calculating <span class="arithmatex">\(A^{-1}\)</span> by Gauss-jordan Elimination  </p>
</blockquote>
<p>前面提过,<span class="arithmatex">\(A^{-1}\)</span> 有<strong>时候不是显式需要</strong>的.方程 <span class="arithmatex">\(Ax = b\)</span> 的解是 <span class="arithmatex">\(x = A^{-1}b\)</span>.但是计算 <span class="arithmatex">\(A^{-1}\)</span> 来乘以b有时候是不必要和不高效的.消去可以直接得到 <code>x</code> .消去其实也是计算 <span class="arithmatex">\(A^{−1}\)</span> 的方法,我们下面就会看到.GJ消去的思想就是求解 <span class="arithmatex">\(AA^{-1}=I\)</span>,然后找到 <span class="arithmatex">\(A^{−1}\)</span> 的<strong>每一列</strong></p>
<p>A乘以 <span class="arithmatex">\(A^{−1}\)</span> 的第一列 (设是 <span class="arithmatex">\(x_1\)</span> )得到 <code>I</code> 的第1列(设是 <span class="arithmatex">\(e_1\)</span> ).这就是我们的方程组:<span class="arithmatex">\(Ax_1  = e_1=(1,0,0)\)</span>.还有另外两个方程组,都是A乘以 $A^{-1} $的列 <span class="arithmatex">\(x_1,x_2,x_3\)</span> 从而得到 <code>I</code> 的列:
$$
A^{-1}\text{的3列:} \quad</p>
<p>A A ^ { - 1 } = A \left[ \begin{array} { l l l } x _ { 1 } &amp; x _ { 2 } &amp; x _ { 3 } \end{array} \right] = \left[ \begin{array} { l l l } e _ { 1 } &amp; e _ { 2 } &amp; e _ { 3 } \end{array} \right] = I \tag{7}
$$
为了求一个 <code>[3 3]</code>矩阵A的逆,我们需要求解<strong>三个</strong>方程组
$$
Ax_1= e_1=(1,0,0)\
Ax_2= e_2=(0,1,0)\
Ax_3= e_3=(0,0,1)
$$
GJ方法是通过<strong>同时求解</strong>n个方程来计算 <span class="arithmatex">\(A^{-1}\)</span> 的.通常增广矩阵 <code>[A b]</code> 有一个附加的列b,. 现在我们有3个附加的列 $e_1,e_2,e_3 $(当A是3-3的时候). 它们都是 <code>I</code> 的列,所以增广矩阵实际上就是一个块矩阵 <code>[A I]</code> .我现在利用这次机会来逆转我最喜欢的矩阵K, 2在主对角线上,而-1在2的旁边:
$$
\begin{aligned} </p>
<p>\left[ \begin{array} { r l l l } K &amp; e _ { 1 } &amp; e _ { 2 } &amp; e _ { 3 } \end{array} \right] &amp; = \left[ \begin{array} { r r r r r r } 2 &amp; - 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ - 1 &amp; 2 &amp; - 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; - 1 &amp; 2 &amp; 0 &amp; 0 &amp; 1 \end{array} \right] </p>
<p>\quad \color{orange} \text{Start GJ on K}</p>
<p>\[4ex] &amp; \rightarrow </p>
<p>\left[ \begin{array} { r r r r r r } 2 &amp; - 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; \frac { 3 } { 2 } &amp; - 1 &amp; \frac { 1 } { 2 } &amp; 1 &amp; 0 \ 0 &amp; - 1 &amp; 2 &amp; 0 &amp; 0 &amp; 1 \end{array} \right] </p>
<p>\quad \color{orange} \frac{1}{2}r_1 + r_2</p>
<p>\[4ex] &amp; \rightarrow </p>
<p>\left[ \begin{array} { r r r r r r } 2 &amp; - 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; \frac { 3 } { 2 } &amp; - 1 &amp; \frac { 1 } { 2 } &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; \frac { 4 } { 3 } &amp; \frac { 1 } { 3 } &amp; \frac { 2 } { 3 } &amp; 1 \end{array} \right] </p>
<p>\quad \color{orange} \frac{2}{3}r_2 + r_3
\end{aligned}
$$</p>
<p>我们已经在寻找 <span class="arithmatex">\(k^{−1}\)</span> 的路上走了一半了.上面矩阵的前三列是U(upper triangular).主元分别是 <code>2,3/2,4/3</code>.都在对角线上,如果是高斯,他会使用向后替换来解决.但是Jordan的贡献在于使用消去来进行化简,直到得到了<strong>简化阶梯形式(reduced echelon form)</strong>: 行被加到它上面的行,从而使得主元上面可以产生0
$$
\left( \begin{array} { l } \text { Zero above } \ \text { third pivot } \end{array} \right) \rightarrow \left[ \begin{array} { r r r r r r } 2 &amp; - 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; \frac { 3 } { 2 } &amp; 0 &amp; \frac { 3 } { 4 } &amp; \frac { 3 } { 2 } &amp; \frac { 3 } { 4 } \ 0 &amp; 0 &amp; \frac { 4 } { 3 } &amp; \frac { 1 } { 3 } &amp; \frac { 2 } { 3 } &amp; 1 \end{array} \right] \quad </p>
<p>\quad \color{orange}  \frac { 3 } { 4 } \text { row 3 +  row 2 }</p>
<p>\[10ex]</p>
<p>\left( \begin{array} { l } \text { Zero above } \ \text { second pivot } \end{array} \right) \rightarrow \left[ \begin{array} { l l l l l l } 2 &amp; 0 &amp; 0 &amp; \frac { 3 } { 2 } &amp; 1 &amp; \frac { 1 } { 2 } \ 0 &amp; \frac { 3 } { 2 } &amp; 0 &amp; \frac { 3 } { 4 } &amp; \frac { 3 } { 2 } &amp; \frac { 3 } { 4 } \ 0 &amp; 0 &amp; \frac { 4 } { 3 } &amp; \frac { 1 } { 3 } &amp; \frac { 2 } { 3 } &amp; 1 \end{array} \right] </p>
<p>\quad  \quad \color{orange}  \frac { 2 } { 3 } \text { row } 2 + \text { row } 1
$$
最后一步，是用它的主元除以它的每一行,新的主元都是1.那么在矩阵的前半部分都是 <code>I</code>,因为k是可逆的,那么 <span class="arithmatex">\([I,K^{−1}]\)</span>的后半部分就是 <span class="arithmatex">\(K^{−1}\)</span>
$$
\begin{array}{r r r}
\text{divide by }&amp; 2: \
\text{divide by }&amp; 3/2: \
\text{divide by }&amp; 4/3:
\end{array}</p>
<p>\quad </p>
<p>\left[ \begin{array} { c c c c c c } 1 &amp; 0 &amp; 0 &amp; \frac { 3 } { 4 } &amp; \frac { 1 } { 2 } &amp; \frac { 1 } { 4 } \ 0 &amp; 1 &amp; 0 &amp; \frac { 1 } { 2 } &amp; 1 &amp; \frac { 1 } { 2 } \ 0 &amp; 0 &amp; 1 &amp; \frac { 1 } { 4 } &amp; \frac { 1 } { 2 } &amp; \frac { 3 } { 4 } \end{array} \right] = \left[ \begin{array} { l l l l } I &amp; x _ { 1 } &amp; x _ { 2 } &amp; x _ { 3 } \end{array} \right] = \left[ \begin{array} { l l } I &amp; K ^ { - 1 } \end{array} \right]
$$</p>
<blockquote>
<p>sp:为什么可以直接一行行的除以一个数呢?从点乘来看,就是等式两边分别除以一个数.如果从AB乘法来看,A的第一行乘以整个B得到AB的第一行,所以可以整行的除</p>
</blockquote>
<p>从<code>[3 6]</code> 的矩阵开始的 <code>[K I]</code>,我们得到了 <span class="arithmatex">\([I,K^{−1}]\)</span>.GJ方法求可逆矩阵A的思想其实就是:
$$
\text{Guass-Jordan:} \quad \text{Multiply } [A,I] \quad  \text{ by }\quad  A^{-1} \quad  \text{ to get } \quad [I,A^{-1}]<br />
$$
对于大矩阵,我们可能不想要计算 <span class="arithmatex">\(A^{−1}\)</span>,但是对于小矩阵,得到逆矩阵是非常值得的.对于特殊的 <span class="arithmatex">\(K^{−1}\)</span>,我们强调一下3个发现,因为这是一个重要的例子.我们引进词语 :对称,三对角,和行列式(symmetric,tridiagonal,determinant)</p>
<blockquote>
<p>sp:来自wikipedia:</p>
<ol>
<li>Sparse matrix:稀疏矩阵,大部分元素是0</li>
<li>Dense Matrix::密集矩阵,大部分元素是1</li>
<li>Band Matrix:带状矩阵,所有的非0元素都在对角线上,这里的对角线,包括主对角线和和主对角线平行的线</li>
<li>tridiagonal Matrix:三对角矩阵,是一个带状矩阵,非0元素只存在于主对角线,主对角线下面的第一个对角线,和主对角线上面的第一个对角线</li>
</ol>
</blockquote>
<ol>
<li>K在主对角线是对称的,<span class="arithmatex">\(K^{−1}\)</span> 也是</li>
<li>k是三对角的,只有3条非0对角线 但是 <span class="arithmatex">\(K^{−1}\)</span>  时候没有0元素的密集矩阵,这就是我们不经常计算逆矩阵的原因.带状矩阵的逆矩阵通常都是一个密集矩阵.</li>
<li>主元乘积是 <span class="arithmatex">\(2(3/2) (4/3)  =  4\)</span>.  等于k的行列式</li>
</ol>
<p><strong>例4</strong> 下面是使用GJ方法求解 <span class="arithmatex">\(A = \left[\begin{matrix} 2 &amp; 3 \\4 &amp; 7 \\\end{matrix} \right]\)</span> 的逆矩阵的操作,有两个行操作和一个除法,来把主元变成1
$$
\left[ \begin{array} { l l } A &amp; I \end{array} \right] </p>
<p>= \left[ \begin{array} { l l l l } 2 &amp; 3 &amp; 1 &amp; 0 \ 4 &amp; 7 &amp; 0 &amp; 1 \end{array} \right] </p>
<p>\rightarrow \left[ \begin{array} { l l l l } 2 &amp; 3 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; - 2 &amp; 1 \end{array} \right] </p>
<p>\quad \text { (this is } \left. \left[ \begin{array} { l l } U &amp; L ^ { - 1 } \end{array} \right] \right)</p>
<p>\[4ex]</p>
<p>\rightarrow \left[ \begin{array} { r r r r } 2 &amp; 0 &amp; 7 &amp; - 3 \ 0 &amp; 1 &amp; - 2 &amp; 1 \end{array} \right] \rightarrow \left[ \begin{array} { r r r r } 1 &amp; 0 &amp; \frac { 7 } { 2 } &amp; - \frac { 3 } { 2 } \ 0 &amp; 1 &amp; - 2 &amp; 1 \end{array} \right] \quad \text { (this is } \left. \left[ \begin{array} { l l } I &amp; A ^ { - 1 } \end{array} \right] \right)
$$
<code>X  =  inverse(A)</code> 的代码可以通过  <code>rref</code> 命令得到,也就是行最简形式.<code>&lt;01-03&gt;</code>讲解</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="n">I</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">eye</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w">         </span><span class="c">% Define the n by n identify matrix</span>
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="n">R</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">rref</span><span class="p">([</span><span class="n">A</span><span class="w"> </span><span class="n">I</span><span class="p">]);</span><span class="w">    </span><span class="c">% Eliminate on the augmented matrix [A I]</span>
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="n">X</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">R</span><span class="p">(:,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">n</span><span class="p">);</span><span class="w">   </span><span class="c">% Pick inverse of A from the last n columns of R</span>
</code></pre></div>
<p>A必须是可逆的,不然消去无法把它化简为<code>I</code>.(也就是R的左半部分)</p>
<p>GJ方法求解 <span class="arithmatex">\(A^{-1}\)</span> 是昂贵的,需要对<strong>n个</strong>列求解了<strong>n个</strong>方程组. 有必要为 <span class="arithmatex">\(A^{−1}\)</span> 辩解一下,计算 <span class="arithmatex">\(A^{−1}\)</span>  的耗费并不是 <code>Ax = b</code> 的n倍.令人惊奇的是,对于n列这个耗费只是乘以3.能够做到如此,是因为n个等式 <span class="arithmatex">\(Ax_i   =  e_i\)</span> 都是同样的系数矩阵<code>A</code> ,对于A,我们只需要进行一次的消去即可.<span class="arithmatex">\(A^{−1}\)</span> 的全部耗费需要 <span class="arithmatex">\(n^3\)</span> 消去步骤 ,而一个单独的 <code>x</code> 需要 <span class="arithmatex">\(n^3  /3\)</span>. <code>&lt;#6&gt;</code>会计算这些耗费.</p>
<h2 id="54">5.4. 奇异和可逆</h2>
<blockquote>
<p>Singular versus Invertable </p>
</blockquote>
<p>我们现在回到中心问题,什么时候矩阵是可逆的?这一节的开始我们提出了主元测试:<span class="arithmatex">\(A^{−1}\)</span>  只有在A有完整的n个主元的情况下才存在(允许行交换). 现在我们可以证明,使用GJ消去法:</p>
<blockquote>
<p><strong>证明：主元完整存在，A可逆</strong></p>
<hr />
<ol>
<li>有了n个主元,消去会求解所有的 <span class="arithmatex">\(Ax_i = e_i\)</span>,求得的每个解作为列向量 <span class="arithmatex">\(x_i\)</span>,是 <span class="arithmatex">\(A^{−1}\)</span> 的列.到这里,就有了 <span class="arithmatex">\(AA^{−1} = I\)</span>,所以 <span class="arithmatex">\(A^{−1}\)</span> 至少是右逆</li>
<li>实际上,消去只是一系列乘以 $E's,P's $ 和一个 <span class="arithmatex">\(D^{−1}\)</span> 的操作</li>
</ol>
<div class="arithmatex">\[
\text{left-inverse}: (D^{-1} ...E...P...E)A = I \tag{9}
\]</div>
<ul>
<li><span class="arithmatex">\(D^{−1}\)</span> 是用来除以主元的</li>
<li>矩阵E是用来在主元之上和之下产生0的</li>
<li>P是在需要的时候用来交换行的</li>
</ul>
<p><code>Eq(9)</code> 的左边的<strong>乘法结果</strong>矩阵明显就是一个左逆</p>
<p>当有了n个主元,我们达到了 <span class="arithmatex">\(A^{−1} A=I\)</span>。<strong>右逆和左逆是相等的</strong>.这其实就是这一节开始的提醒2.所以一个正方形矩阵,当n个主元都存在的时候,总有一个双边逆(two-sided inverse).</p>
</blockquote>
<p>然后再证明,如果 <span class="arithmatex">\(AC = I\)</span>,那么A必须有n个主元.然后我们会推导,C也是一个左逆,<span class="arithmatex">\(CA = I\)</span>.下面是证明思想（反证法）</p>
<blockquote>
<p><strong>证明：A可逆，主元完整存在</strong></p>
<hr />
<ol>
<li>如果 A 没有n个主元,那么消去会得到一个全0行</li>
<li>因为这些消去步骤是通过一个 <strong>可逆的</strong> M矩阵进行的,所以 <code>MA</code> 的其中一行全是0</li>
<li>如果 <span class="arithmatex">\(AC = I\)</span> 是可能的,那么 <code>MAC = MI =  M</code>， <code>MA</code> 有全0行,乘以C后，也肯定有全0行，所以M有全0行</li>
<li>但是一个可逆矩阵不可能有去全0行! 所以如果 <span class="arithmatex">\(AC = I\)</span>, 那么A必须有n个主元</li>
</ol>
</blockquote>
<p>上面的分析经过4个步骤,但是结论很简单也很重要</p>
<blockquote>
<p>消去过程,其实对<strong>方阵</strong> 的可逆性做了一次完全测试.当 A 存在 n 个主元,那么 <span class="arithmatex">\(A^{−1}\)</span> 就存在,而且 GJ 方法可以求得 <span class="arithmatex">\(A^{−1}\)</span>.而且上述的分析,揭示的其实更多
$$
\text{如果} \quad AC= I \quad \text{那么}  \quad CA= I \quad \text{而且} C= A^{-1}
$$</p>
</blockquote>
<hr />
<p><strong>例5</strong> 如果 <code>L</code> 是一个主对角线是1的下三角,那么 <span class="arithmatex">\(L^{−1}\)</span> 也是: <strong>一个三角矩阵,当且仅当对角线元素全非0的时候,才是可逆的.</strong></p>
<p>下面的L在主对角线上有1's,所以 <span class="arithmatex">\(L^{−1}\)</span> 也有.使用 <code>GJ</code> 方法来构造 <span class="arithmatex">\(L^{−1}\)</span>.行减去行之间乘以主元,通常只在寻找逆矩阵的路上走了一半.但是 <code>L</code> 可以立刻得到逆矩阵.当 <code>I</code> 出现在左边的时候,<span class="arithmatex">\(L^{−1}\)</span> 就出现在右边了.
$$
\begin{aligned}</p>
<p>\color{orange} \text{G-J on triangular L:} \quad</p>
<p>[L,I] &amp;= \left[ \begin{array} { l l l l l l } 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 3 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 4 &amp; 5 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \end{array} \right]</p>
<p>\[6ex]</p>
<p>&amp; \Rightarrow</p>
<p>\left[ \begin{array} { l l l l l l } 
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 
0 &amp; 1 &amp; 0 &amp; -3 &amp; 1 &amp; 0 \ 
0 &amp; 5 &amp; 1 &amp; -4 &amp; 0 &amp; 1 \end{array} 
\right]
\color{orange} r2-3r_1,r3-4r_1,r3-5r_2</p>
<p>\[6ex]</p>
<p>&amp; \Rightarrow</p>
<p>\left[ \begin{array} { l l l l l l } 
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 
0 &amp; 1 &amp; 0 &amp; -3 &amp; 1 &amp; 0 \ 
0 &amp; 0 &amp; 1 &amp; 11 &amp; -5 &amp; 1 
\end{array} \right]</p>
<p>=  </p>
<p>\color{orange} [I,L^{-1}]</p>
<p>\end{aligned}
$$
在 <code>L</code> 达到 <code>I</code> 的过程,其实也就是一系列消去矩阵 $ E =E_{32} E_{31} E_{21}$ 的乘法,也就是 <span class="arithmatex">\(E[L,I] = [I,L^{-1}]\)</span> .所以乘法结果 <code>E</code> 就是<span class="arithmatex">\(L^{−1}\)</span>, <span class="arithmatex">\(L^{−1}\)</span> 的主对角线也都是1,也是一个下三角,注意 <span class="arithmatex">\(L^{−1}\)</span> 包含了11,也是也就是 <span class="arithmatex">\(3*5 - 4\)</span>。但，这个11，在更好的顺序  <span class="arithmatex">\(E_{21}^{−1} E_{31}^{−1} E_{32}^{−1}=  L\)</span> 中不会出现。</p>
<h2 id="55">5.5. 典型例题</h2>
<p><strong>1.</strong> 一个三角差分矩阵(triangular difference matrix) A的逆矩阵是一个三角和矩阵(triangular sum matrix S):
$$
\left[ \begin{array} { l l } A &amp; I \end{array} \right] = \left[ \begin{array} { r r r | r r r } 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ - 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; - 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \end{array} \right] \rightarrow \left[ \begin{array} { r r r | r r r } 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \ 0 &amp; - 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \end{array} \right] \</p>
<p>\rightarrow \left[ \begin{array} { l l l | l l l } 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{array} \right] = \left[ \begin{array} { l l } I &amp; A ^ { - 1 } \end{array} \right] = \left[ \begin{array} { l l } I &amp; \text { sum matrix } \end{array} \right]
$$
如果把 <span class="arithmatex">\(a_13\)</span> 改为-1,那么A的每一行的和都是0,等式 <code>Ax = 0</code> 将会得到一个非0解 <code>x = (1,1,1)</code>:这个新的A是不可逆的!</p>
<hr />
<p><strong>2.</strong> 使用GJ方法来逆<strong>下三角</strong>三角帕斯卡矩阵 L.回忆一下,L的每一个元素都是二项式系数(<code>&lt;#4.6&gt; 典型例题</code>).如下所示,下一行是1,4,6,4,1
$$
L = \left[ \begin{array} { l l l l } 1 &amp; 0 &amp; 0 &amp; 0 \ 1 &amp; 1 &amp; 0 &amp; 0 \ 1 &amp; 2 &amp; 1 &amp; 0 \ 1 &amp; 3 &amp; 3 &amp; 1 \end{array} \right] = a b s ( \text { pascal } ( 4,1 ) )
$$
解: 开始对 <code>[L,I]</code> GJ
$$
[ L,I ] = \left[ \begin{array} { l l l l | l l l l } 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \ 1 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \ 1 &amp; 3 &amp; 3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \end{array} \right] </p>
<p>\overset{\text{主元1下产生0}}{\rightarrow}</p>
<p>\left[ \begin{array} { l l l l | r l l l } 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 &amp; - 1 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 2 &amp; 1 &amp; 0 &amp; - 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 3 &amp; 3 &amp; 1 &amp; - 1 &amp; 0 &amp; 0 &amp; 1 \end{array} \right]</p>
<p>\[10ex]</p>
<p>\overset{\text{主元2下产生0}}{\rightarrow}
\left[ \begin{array} { l l l l | r r r r } 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 &amp; - 1 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 &amp; \vec { 1 } &amp; - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 3 &amp; 1 &amp; 2 &amp; - 3 &amp; 0 &amp; 1 \end{array} \right] </p>
<p>\[10ex]</p>
<p>\overset{\text{主元3下产生0}}{\rightarrow} \left[ \begin{array} { r r r r | r r r r } 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 0 &amp; - 1 &amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 0 &amp; 1 &amp; - 1 &amp; 3 &amp; - 3 &amp; 1 \end{array} \right] = \left[ I，L ^ { - 1 } \right]
$$
全部的主元都是1！所以不用把行除以主元了！<span class="arithmatex">\(L^{−1}\)</span> 和L是很像的,只是奇数对角线元素都是负号.对于n-n的帕斯卡矩阵也是如此的,<span class="arithmatex">\(L^{−1}\)</span> 拥有<strong>交替对角线(alternating diagonals)</strong></p>
<h1 id="6-a-lu">6. A= LU : 消去=因式分解</h1>
<blockquote>
<ul>
<li>Elimination=Factorization:A = LU</li>
<li>这一节综合了视频4</li>
</ul>
</blockquote>
<p>很多学生都会觉得数学课程太理论化了.但是这一节不是.这一节的目的就是用最有用的方式描述GJ消去法.线性代数的很多关键概念,当你仔细的看它们的时候,实际上就是矩阵的<strong>因式分解(factorization of a matrix)</strong>.原始的矩阵A变成2个或者3个特别矩阵的乘积.第一个分解,也是实践中最重要的分解: <strong>来自于消去,因子L和U是三角矩阵</strong>.</p>
<h2 id="61-a-lu">6.1. A = LU</h2>
<p>消去步骤会把A变成U.我们现在会展示怎么逆这些步骤(把U变成A):可以通过一个下三角矩阵L得到,L的元素就是乘数 <span class="arithmatex">\(\ell_{ij}\)</span>: 
$$
\begin{array} { l }</p>
<p>\text{从A到U:}  &amp;\quad E _ { 21 } A = \left[ \begin{array} { r r } 1 &amp; 0 \ - 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l l } 2 &amp; 1 \ 6 &amp; 8 \end{array} \right] =  \left[\begin{matrix} 2 &amp; 1 \ 0 &amp; 5 \end{matrix} \right] = U </p>
<p>\[4ex]</p>
<p>\text{从U回到A:} &amp;\quad  E _ { 21 } ^ { - 1 } U = \left[ \begin{array} { l l } 1 &amp; 0 \ 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l l } 2 &amp; 1 \ 0 &amp; 5 \end{array} \right] = \left[ \begin{array} { l l } 2 &amp; 1 \ 6 &amp; 8 \end{array} \right] = A \end{array}
$$
第二行就是分解 <code>LU = A</code>.我们把 <span class="arithmatex">\(E_{21}^{−1}\)</span> 写成了L.如果是更大的矩阵,包含了很多E,那么<strong>L是它们所有的逆的乘积</strong></p>
<p>A到U的每一个步骤都乘以一个矩阵 <span class="arithmatex">\(E_{ij}\)</span>,用来在 <code>(i,j)</code> 位置产生了一个0.为了描述清楚过程,我们用没有行交换发生的例子说明.如果A是3-3的,那么我们将会乘以 <span class="arithmatex">\(E_{21},E_{31},E_{32}\)</span> ,从而在 <code>(2,1),(3,1),(3,2)</code> 位置产生0.最终得到的是一个上三角矩阵。 现在把这些E放到另外一边,也就是它们的逆矩阵乘以U
$$
\left( E _ { 32 } E _ { 31 } E _ { 21 } \right) A = U \quad \text { 变成 } \quad A = \left( E _ { 21 } ^ { - 1 } E _ { 31 } ^ { - 1 } E _ { 32 } ^ { - 1 } \right) U \quad \text { 也就是 } \quad A = L U   \tag{1}
$$
这些逆操作是<strong>相反的</strong>顺序.这三个逆矩阵的乘积是L.最终我们得到 <code>A = LU</code>.我们停在这里,开始理解</p>
<h3 id="611">6.1.1. 解释和例子</h3>
<blockquote>
<p>Explanation and examples</p>
</blockquote>
<p><strong>第1点:</strong> 每一个逆矩阵 <span class="arithmatex">\(E^{−1}\)</span> 是一个下三角,<strong>非</strong>对角线的元素都是 <span class="arithmatex">\(\ell{ij}\)</span> ,来抵消 E 矩阵 <span class="arithmatex">\(-\ell_{ij}\)</span> 产生的减去。E 和 <span class="arithmatex">\(E^{-1}\)</span> 的对角线都是1。在我们上面的例子当中：
$$
\ell_{21} = 3,E = \left[\begin{matrix} 1 &amp; 0 \ -3 &amp; 1 \end{matrix} \right]
,L = \left[\begin{matrix} 1 &amp; 0 \ 3 &amp; 1 \end{matrix} \right]
$$
<strong>第2点:</strong> Eq(1) 展示的是一个下三角矩阵( <span class="arithmatex">\(E_{ij}\)</span> 们的乘积)乘以矩阵A,也展示了所有的 <span class="arithmatex">\(E_{ij}^{−1}\)</span>  乘以U把U变回A.这些下三角矩阵的<strong>逆的乘积</strong>是L. </p>
<p>使用这些逆矩阵的一个原因就是我们<strong>想要分解A,而不是U</strong>.逆形式(inverse form)得到A = LU.另外的惊喜是，L很容易求得的。参见第3点</p>
<p><strong>第3点:</strong> 每一个乘数 <span class="arithmatex">\(\ell_{ij}\)</span> 都恰好的，不改变的位于 逆矩阵乘积 <code>L</code> 矩阵的 <code>(i,j)</code> 位置。通常矩阵乘法会打乱数字，但这里不会，这些逆矩阵乘法的顺序恰好保证了 <span class="arithmatex">\(\ell's\)</span> 不会变化，原因在下面的 Eq(3) 给出。</p>
<p>因为每一个 <span class="arithmatex">\(E^{−1}\)</span> 的主对角线都是1,最后的美好的一点就是: L也是如此的</p>
<blockquote>
<p><strong>A = LU(无行交换）总结</strong></p>
<hr />
<ul>
<li>上三角U的主对角线都是主元</li>
<li>下三角L的对角线都是1，而且乘数 <span class="arithmatex">\(\ell_{ij}\)</span> 在 L 的对角线之下 </li>
</ul>
</blockquote>
<p><strong>例1</strong> 消去把 <code>1/2 r1</code> 从 <code>r2</code> 减去,然后把 <code>2/3 r2</code> 从r3减去.下三角L有 <span class="arithmatex">\(\ell_{21} = 1/2,\ell_{23} = 2/3\)</span>, LU相乘得到A
$$
A = \left[ \begin{array} { l l l } 2 &amp; 1 &amp; 0 \ 1 &amp; 2 &amp; 1 \ 0 &amp; 1 &amp; 2 \end{array} \right] =</p>
<p>\left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ \frac { 1 } { 2 } &amp; 1 &amp; 0 \ 0 &amp; \frac { 2 } { 3 } &amp; 1 \end{array} \right] \left[ \begin{array} { l l l } 2 &amp; 1 &amp; 0 \ 0 &amp; \frac { 3 } { 2 } &amp; 1 \ 0 &amp; 0 &amp; \frac { 4 } { 3 } \end{array} \right] = L U
$$
<code>(3,1)</code> 位置的乘数是0,因为A的 <code>(3,1)</code> 元素是0,不需要继续操作,所以可以看到,L主对角线下的 <code>(i,j)</code> 元素就是 <span class="arithmatex">\(\ell_{ij}\)</span> !</p>
<hr />
<p><strong>例2</strong> 在例1当中,如果把A的左上角元素从2改为1.主元都变成了1.乘数现在都是1.当A是4-4的时候,也是这种模式
$$
A = \left[ \begin{array} { l l l l } 1 &amp; 1 &amp; 0 &amp; 0 \ 1 &amp; 2 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 2 &amp; 1 \ 0 &amp; 0 &amp; 1 &amp; 2 \end{array} \right] = \left[ \begin{array} { l l l l } 1 &amp; &amp; &amp; \ 1 &amp; 1 &amp; &amp; \ 0 &amp; 1 &amp; 1 &amp; \ 0 &amp; 0 &amp; 1 &amp; 1 \end{array} \right] \left[ \begin{array} { l l l l } 1 &amp; 1 &amp; 0 &amp; 0 \ &amp; 1 &amp; 1 &amp; 0 \ &amp; &amp; 1 &amp; 1 \ &amp; &amp; &amp; 1 \end{array} \right]
$$</p>
<p>这些LU的例子展示了一些重要的信息,在实践中是很重要的.<strong>假设没有行交换发生</strong>,我们怎么预测L,U当中的0元素呢?</p>
<ul>
<li>当A的一行以0开始，L也是</li>
<li>当A的一列以0开始，U也是</li>
</ul>
<p>当一行以0开始,我们不需要进行消去的步骤.所以有L有一个0,这可以节省计算时间.类似的,在列开始的0存活到U,但是请意识到,消去，矩阵中间的0可能会被填充。</p>
<h3 id="612">6.1.2. 视频例子</h3>
<blockquote>
<p>来自视频4</p>
</blockquote>
<h4 id="6121-2-2">6.1.2.1. 2-2例子</h4>
<p>我们从 <code>[2 2]</code> 矩阵 <span class="arithmatex">\(A= \left[\begin{matrix} 2 &amp;1 \\8 &amp; 7 \\\end{matrix} \right]\)</span>,使用初等矩阵进行变换
$$
E _ { 21 }A = E_{21} \left[ \begin{array} { l l } 2 &amp; 1 \ 8 &amp; 7 \end{array} \right] = \left[ \begin{array} { c c } 1 &amp; 0 \ - 4 &amp; 1 \end{array} \right] \left[ \begin{array} { l l } 2 &amp; 1 \ 8 &amp; 7 \end{array} \right] = \left[ \begin{array} { l l } 2 &amp; 1 \ 0 &amp; 3 \end{array} \right] = U
$$
我们想要 A=LU ,那么在上式当中,<code>L</code> 是什么，它和 <code>E</code> 的关系是什么?<strong>逆</strong>!这是因为如果 <code>EA = U</code> 两边都乘以E的逆,那么就是 <span class="arithmatex">\(A = E^{−1} U\)</span>.所以 <span class="arithmatex">\(L = E^{-1}!\)</span> 那么 <span class="arithmatex">\(E^{-1}\)</span> 是多少么？ 是 <span class="arithmatex">\(\left[\begin{matrix} 1 &amp;0 \\4 &amp; 1 \\\end{matrix} \right]\)</span> ,只需要 <span class="arithmatex">\(E_{21}\)</span> 改变一个正负号即可.最终我们得到的是
$$
\underbrace{\left[ \begin{array} { l l } 2 &amp; 1 \ 8 &amp; 7 \end{array} \right] }_A</p>
<p>= </p>
<p>\underbrace{\left[ \begin{array} { l l } 1 &amp; 0 \ 4 &amp; 1 \end{array} \right] }_L</p>
<p>\quad</p>
<p>\underbrace{\left[ \begin{array} { l l } 2 &amp; 1 \ 0 &amp; 3 \end{array} \right]}_U
$$
有时候我们会把主元单独列出来,也就是
$$
\underbrace{ \left[ \begin{array} { l l } 2 &amp; 1 \ 8 &amp; 7 \end{array} \right]}_A </p>
<p>= </p>
<p>\underbrace{\left[ \begin{array} { l l } 1 &amp; 0 \ 4 &amp; 1 \end{array} \right]}_{L}</p>
<p>\underbrace{\left[ \begin{array} { l l } 2 &amp; 0 \ 0 &amp; 3 \end{array} \right]}_{D}</p>
<p>\underbrace{\left[\begin{matrix} - &amp; - \- &amp; - \\end{matrix} \right]}_U
$$
那么现在<code>U</code> 是什么呢? <span class="arithmatex">\(DU_{new}  =U_{old}\)</span>.那么</p>
<ul>
<li><span class="arithmatex">\(U_{old}\)</span> 的 <code>r1</code> 是 <span class="arithmatex">\(U_{new}\)</span>  的 <code>r1</code> 的两倍</li>
<li><span class="arithmatex">\(U_{old}\)</span> 的 <code>r2</code> 是 <span class="arithmatex">\(U_{new}\)</span> <code>r2</code>的3倍</li>
</ul>
<p>那么 <span class="arithmatex">\(U_{new}\)</span> 就是 <span class="arithmatex">\(\left[\begin{matrix} 1 &amp; 1/2 \\0 &amp; 1 \\\end{matrix} \right]\)</span> .现在 <code>LU</code> 变成 <code>LDU</code> 了(D是<strong>对角矩阵</strong>),<code>LDU</code>式子更加平衡:<strong>LU都是三角矩阵,D是对角矩阵.</strong></p>
<h4 id="6122-3-3">6.1.2.2. 3-3例子</h4>
<p>假设矩阵A是 <code>[3 3]</code> 的,那么消元就是在主元下面产生0.也就是
$$
E_{32} E_{31} E_{21} A=U  \quad \text{（假设无行交换）}
$$
前面的3个E矩阵可以乘起来得到一个单独的矩阵E.但是我们想要<span class="arithmatex">\(E^{−1}\)</span> 出现在右侧,也就是<code>A = LU</code> 的 <code>L</code>.</p>
<ul>
<li><span class="arithmatex">\(E_{32} E_{31} E_{21} A=U →A=LU\)</span>,那么L就是那3个E的乘积的<strong>逆</strong>,也就是</li>
<li><span class="arithmatex">\(A = LU →A= E_{21}^{−1} E_{31}^{−1} E_{32}^{−1} U\)</span> ,L其实就是这些E的逆的乘积.</li>
</ul>
<p>也许你会问,为什么我们需要逆的形式,而不是普通的 <code>EA = U</code> 的形式.我们举例解释一下.在 <code>[2 2]</code> 的时候,只会有一个E, <code>[3 3]</code> 的时候,就会有3个E(典型情况下).现在我们假设3-3例子当中,有
$$
E _ { 21 } = \left[ \begin{array} { c c c } 1 &amp; 0 &amp; 0 \ - 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] , E _ { 32 } = \left[ \begin{array} { c c c } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; - 5 &amp; 1 \end{array} \right]</p>
<p>\text{没有} E_{31},\text{这里是为了简单说明}
$$
现在我们进行乘法,对角线都是1,对角线之上都是0.
$$
E _ { 32 } E _ { 21 } = \left[ \begin{array} { c c c } 1 &amp; 0 &amp; 0 \ - 2 &amp; 1 &amp; 0 \ 10 &amp; - 5 &amp; 1 \end{array} \right]
$$
这个 10 是个麻烦,不好处理.它是怎么来的呢?这是因为 <span class="arithmatex">\(r2 - 2*r1\)</span>.而 <span class="arithmatex">\(r3 - 5*r2\)</span>.所以 <code>r3</code> 一共加上了 <code>10*r1</code> ,因此出现了10.</p>
<p>现在我们使用逆的性质,反过来看一下:</p>
<p><span class="arithmatex">\(E^{−1}= E_{21}^{−1} E_{32}^{−1}\)</span>, <span class="arithmatex">\(E_{21}\)</span> 和 <span class="arithmatex">\(E_{32}\)</span> 的逆分别是什么呢? <span class="arithmatex">\(E_{21}\)</span> 原来是 <span class="arithmatex">\(r2-2*r1\)</span>,现在加回去不就得了.那就是说
$$
E _ { 21 } ^ { - 1 } E _ { 32 } ^ { - 1 } = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 2 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 5 &amp; 1 \end{array} \right]  </p>
<p>= \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 2 &amp; 1 &amp; 0 \ 0 &amp; 5 &amp; 1 \end{array} \right] = L
$$
结果是令人愉快的。 <span class="arithmatex">\(EA = U\)</span>,而 <span class="arithmatex">\(A = LU\)</span>.L形式矩阵相乘的顺序非常好,2和5不会冲突,不会得到10.这种顺序,消元的乘数(也就是2和5)还是在L里面的.这是关键,要求出L,不需要任何额外运算,只需要把所有的消元乘数都写进来,就能得到L. </p>
<p>总结一下,对于A = LU,如果没有行交换,<code>消元乘数</code> 那个倍数,可以直接写进L中.因此,可以这样看待消元,只要消元步骤正确,可以在得到 <code>LU</code> 的过程中把A抛开,只要保留U，和消元乘数(在L里面),A是什么就可以不管了,因为A的信息都包含在 <code>LU</code> 了,因此,这是关于消元的全新认识,以矩阵形式进行消元更深刻的认识.</p>
<p>我们不知道一连串E的乘积E是什么,E矩阵并不令人着迷,令人着迷是把它们的逆的反顺序乘积放在另外一侧,这样可以轻松得到L.</p>
<h3 id="613-alu">6.1.3. A=LU的关键原因</h3>
<p>试想一下，那些<code>需要被前面的行减去的主元行</code>(pivot rows)</p>
<ol>
<li>它们是A的原始行吗?不是,消去很大可能会改变它们</li>
<li>它们是U的行吗? 是的，因为某行经过消去后，这个主元行再也不改变了</li>
</ol>
<blockquote>
<p>sp:理解一下：所谓 <code>被前面的行减去的主元行</code>：就是r2开始啊，如A的r2，需要被r3,r4减去。而r2，也需要被r1减去</p>
<p>然后，<strong>某一行经过消去之后，再也不改变了</strong>，然后可以被后面的行继续减去。</p>
</blockquote>
<p>当计算 U 的第 3 行的时候，我们减去的是<strong>U的前面行，而不是A的</strong>！
$$
U_{r3}  = A_{r3} - \ell _ { 31 } U_{r1} - \ell _ { 32 } U_{r2}</p>
<p>\tag{2}
$$
重写上述等式，可发现,行  <span class="arithmatex">\([ \ell_{31},\ell_{32},1]\)</span> 是乘以U(sp:这个 <code>1</code> 是 <span class="arithmatex">\(\ell_{33}\)</span> )
$$
A_{r3} =  \ell _ { 31 } U_{r1} + \ell _ { 32 } U_{r2} + 1U_{r_3}  \tag{3}
$$</p>
<p><strong>这就恰好是A = LU 的第三行！</strong> <strong>L 的第3行保留着 <span class="arithmatex">\([ \ell_{31},\ell_{32},1]\)</span>,</strong>其他所有行都是如此。当<strong>没有行交换发生，我们就有 A = LU。</strong></p>
<hr />
<p><strong>例 4</strong>  我们看一下上述思想过程 ：Ax = b 到 三角 的 Ux = c</p>
<blockquote>
<p>sp:来自习题3</p>
</blockquote>
<div class="arithmatex">\[
\begin{array} { l r r r } x + y + z = 5 &amp; x + y + z = 5 &amp; x + y + z = 5 \\ x + 2 y + 3 z = 7 &amp; y + 2 z = 2 &amp; y + 2 z = 2 \\ x + 3 y + 6 z = 11 &amp; 2 y + 5 z = 6 &amp; z = 2 \end{array}
\]</div>
<p>Ux = c 当中的 <code>z=2</code> 来自于 Ax = b 当中的 <code>x+3y+6z = 11</code> 减去 <span class="arithmatex">\(\ell_{31} = 1\)</span> 乘以方程1 ，再减去 <span class="arithmatex">\(\ell_{32}\)</span> 乘以新的方程2.我们可以从 Ux = c 的三行 <code>[1 1 1 5];[0 1 2 2];[0 0 1 2]</code> 恢复原始A,b 的最后一行 <code>[1 3 6 11]</code>
$$
\text{Row 3} \text { of } [ A,b ] = \left( \ell _ { 31 } \text { Row } 1 + \ell _ { 32 } \text { Row } 2 + 1 \right. \text { Row 3) of } [ U \quad c ]
$$
在矩阵语言下，这就是被L乘，也就是 <span class="arithmatex">\(LU = A,Lc = b\)</span> ！</p>
<h3 id="614-a-ldu">6.1.4. 更好的形式：A = LDU</h3>
<p>LU分解不是对称的,因为U的对角线是主元,而L的对角线是1.这很容易调整:  <strong>把U除以包含主元的对角矩阵D</strong>.这就就产生一个新的矩阵D,对角线上是1 ,也就是 <span class="arithmatex">\(U_{old}  = DU_{new}\)</span>
$$
\text {Split U into:} \quad 
\left[ \begin{array} { c c c c c c } d _ { 1 } &amp; &amp; &amp; \ &amp; d _ { 2 } &amp; &amp; \ &amp; &amp; \ddots &amp; \ &amp; &amp; &amp; &amp; d _ { n } \end{array} \right] \left[ \begin{array} { c c c c } 1 &amp; u _ { 12 } / d _ { 1 } &amp; u _ { 13 } / d _ { 1 } &amp; \cdot \ &amp; 1 &amp; u _ { 23 } / d _ { 2 } &amp; \cdot \ &amp; &amp; \ddots &amp; \vdots \ &amp; &amp; &amp; 1 \end{array} \right]
$$
这样的话,<span class="arithmatex">\(U_{new}\)</span> 对角线和 <code>L</code> 一样就变成了1.现在 <code>LU</code> 分解变成 <code>LDU</code>分解: <code>下三角L * 对角矩阵D  * 上三角U</code>:
$$
\text{The triangular facrorization can be written :} \quad A = L U \text { or } A = L D U
$$
每当你看见LDU,就可以理解为U的主对角线都是1,这是通过把 <span class="arithmatex">\(U_{old}\)</span> 的每一行除以此行第一个非0元素,也就是主元得到的
$$
\left[ \begin{array} { l l } 1 &amp; 0 \ 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l l } 2 &amp; 8 \ 0 &amp; 5 \end{array} \right] \quad \text { splits further into } \left[ \begin{array} { l l } 1 &amp; 0 \ 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l l } 2 &amp; \ &amp; 5 \end{array} \right] \left[ \begin{array} { l l } 1 &amp; 4 \ 0 &amp; 1 \end{array} \right] \tag{4}
$$
主元2,5跑到D去了. 把行除以2,5在 <span class="arithmatex">\(U_{new}\)</span> 留下的行 <code>[1 4]</code>  和 <code>[0  1]</code>  而且主对角线变成1.乘数3还是在L里</p>
<h2 id="62-2">6.2. 一个正方形系统=2个三角形系统</h2>
<blockquote>
<p>One Square System=Two triangular Systems</p>
</blockquote>
<p>L包含了消去的乘数的记录,我们怎么利用这些记录来求解Ax = b呢?下面是步骤</p>
<ol>
<li><strong>分解(factor)</strong>：把 A 分解为 LU  </li>
<li><strong>求解(solve)</strong>: 用 L 对 b 进行前进消去，然后用 U 对 x 进行向后替换(Forward elimination on <code>b</code> using <code>L</code>,then back substitution for <code>x</code> using <code>U</code>)</li>
</ol>
<p>一开始,我们使用增广矩阵 <code>[A b]</code> 来求解,但是很多的计算机系统会把 <code>A</code>和 <code>b</code> 分开处理,因为，消去的信息已经包含在 <code>L</code>和 <code>U</code> 里面,利用这些信息，可以在任何需要的时候，再处理b.  <code>LAPACK User Gudies</code> 的文档就有说明：</p>
<blockquote>
<p>This situation is so common and the savings are so important that no provision has been made for solving a single system with just one subroutine</p>
</blockquote>
<p>那么求解阶段是对b是如何处理的呢?</p>
<ol>
<li>首先，对方程右边的 <code>b</code> ，利用L(包含了消去乘数，现在使用),进行<strong>向前消去(forward elimination)</strong>,使得 <code>b</code> 变成 <code>c</code>,c作为新的右边向量</li>
<li>然后，是和以前一样，对 <code>Ux = c</code> 使用向后替换.那么原始的一个Ax = b的系统分解成两个三角系统:</li>
</ol>
<div class="arithmatex">\[
\text{Forward and backward:} \quad L c = b \quad \text { 然后求解 } \quad U x = c  \tag{5}
\]</div>
<p>为了验证这是正确的,把 <code>Ux = C</code> 乘以L,得到 <code>LUx = Lc</code> ,也就是 <code>Ax= b</code></p>
<p><strong>例3</strong> 对 <code>Ax = b</code> 向前消去,结束于 <code>Ux = c</code>
$$
Ax = b: \begin{cases}
u + 2 v &amp;= 5 \
4u+9v &amp;= 21
\end{cases}</p>
<p>\quad  \text { 变成 }  \quad  U x = c:\quad </p>
<p>\begin{cases}
u + 2 v &amp;= 5 \ 
v &amp;= 1 
\end{cases}
$$</p>
<p>乘数是4,存在L里面,b使用这个乘数把21变为1
$$
L c = b：\quad  \left[ \begin{array} { l l } 1 &amp; 0 \ 4 &amp; 1 \end{array} \right] [ c ] = \left[ \begin{array} { r } 5 \ 21 \end{array} \right] \Rightarrow \quad 
c = \left[ \begin{array} { l } 5 \ 1 \end{array} \right]</p>
<p>\quad \color{orange} \text{下三角系统}</p>
<p>\</p>
<p>U x = c ：\quad  \left[ \begin{array} { l l } 1 &amp; 2 \ 0 &amp; 1 \end{array} \right] [ x ] = \left[ \begin{array} { l } 5 \ 1 \end{array} \right] \Rightarrow \quad </p>
<p>x = \left[ \begin{array} { l } 3 \ 1 \end{array} \right]<br />
\quad \color{orange} \text{上三角系统}
$$</p>
<h2 id="63">6.3. 消去的花费</h2>
<blockquote>
<p>The cost of elimination </p>
</blockquote>
<p>如果我们可以在PC上求解1000个方程,那么100000个呢?在科学计算当中,大系统是经常出现的.就算是三维情况下也可能经常出现百万个未知数.</p>
<ol>
<li>
<p>消去的第一个步骤,就是在第一列,在主元下面产生一整列的0.每在一个主元下面产生一个0,需要 <code>乘数*主元所在的行</code> ,再被<code>需要消去的行减去</code>.这需要 <span class="arithmatex">\(n^2\)</span> 次乘法和 <span class="arithmatex">\(n^2\)</span>  次减法.其实实际的次数少一点,是 <span class="arithmatex">\(n^2  −n\)</span>,因为 <code>r1</code> 并不需要改变</p>
</li>
<li>
<p>下一步就是在第2个主元所在的列下面产生0元素.这时候其实可以看成是整个矩阵的数目变成 <code>n -1</code>.那么需要的数目可以估计为 <span class="arithmatex">\((n−1)^2\)</span> 乘法和减法</p>
</li>
<li>
<p>最终就是需要处理的矩阵越来越小,总的次数是
$$
n ^ { 2 } + ( n - 1 ) ^ { 2 } + \cdots + 2 ^ { 2 } + 1 ^ { 2 } = \frac { 1 } { 3 } n \left( n + \frac { 1 } { 2 } \right) ( n + 1 )
$$
当n很大的时候,近似于 <span class="arithmatex">\(1/3 n^3\)</span>.所以，<strong>对A进行消去需要大约  <span class="arithmatex">\(1/3 n^3\)</span> 乘法和 <span class="arithmatex">\(1/3 n^3\)</span> 减法</strong></p>
</li>
<li>
<p>那么右边的b呢?我们把 <span class="arithmatex">\(b_1\)</span> 乘以乘数,然后被 <span class="arithmatex">\(b_2,b_3…b_n\)</span> 减去,有 <span class="arithmatex">\(n - 1\)</span> 步,下一次就是 <span class="arithmatex">\(n -2\)</span>步....</p>
</li>
<li>
<p>现在开始回代.计算 <span class="arithmatex">\(x_n\)</span> 需要一步就可以了,也就是除以最后一个主元. <span class="arithmatex">\(x_{n−1}\)</span> 需要2步... <span class="arithmatex">\(x_1\)</span> 需要n步(n-1个其他未知数替换，和一步用来除以第一个主元),那么右侧的总数:从b到c到x，也就是从上到下再从下到上--刚好是 <span class="arithmatex">\(n^2\)</span>
$$
[ ( n - 1 ) + ( n - 2 ) + \cdots + 1 ] + [ 1 + 2 + \cdots + ( n - 1 ) + n ] = n ^ { 2 } \tag{6}
$$
右边的耗费比左边的少很多：<strong>每一个右侧的b，需要 <span class="arithmatex">\(n^2\)</span> 次乘法和 <span class="arithmatex">\(n^2\)</span> 次减法</strong></p>
</li>
</ol>
<h3 id="631">6.3.1. 带状矩阵</h3>
<p>一个带状矩阵(band matrix) B,在主对角线之上和之下，分别有w条<strong>非零</strong>对角线.在带状外围的0元素在消去后也会保留(L和U当中的0元素).把第一列置为0需要 <span class="arithmatex">\(w^2\)</span> 次乘法和减法(因为有w个非零元素在主元下面,每一个非零元素的行的长度是w),那么n行需要的次数不超过 <span class="arithmatex">\(nw^2\)</span></p>
<blockquote>
<p>sp:这里是这样的，如下左图，图中的d就是w.是针对每个 <code>[w-w]</code> 的小矩形消去即可，一共有n个，所以是 <span class="arithmatex">\(nw^2\)</span>. 而每个 <code>[w-w]</code> 小矩阵的消去，只需要消去第一列！</p>
<p><img alt="image-20210107135812798" src="../.assets/image-20210107135812798.png" /></p>
</blockquote>
<p>这可以节省很多时间
$$
\text{带状矩阵：} 
\begin{cases}
分解阶段：\quad \frac { 1 } { 3 } n ^ { 3 } \text { 变为 } n w ^ { 2 } \
求解阶段：\quad n ^ { 2 } \text { 变为 } 2 n w 
\end{cases}
$$</p>
<h2 id="64-matlab-ax-b">6.4. matlab Ax =b 代码</h2>
<blockquote>
<p>sp：还可参见 <code>&lt;A10-01&gt;</code></p>
</blockquote>
<p>下面是把A分解成LU很求解 <code>Ax = b</code> 的代码.代码  <code>slu</code> 在一遇到主元位置小于容忍度 <code>tol</code> 的时候就停止.这些代码在<code>web.mit.edu/18.06/www</code>.更加专业的代码,会查看每一列,寻找最大的可用主元来交换并且继续求解下去。MATLAB的反斜杠命令 <code>x  =  A \b</code> 组合了分解和求解,来得到x </p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="k">function</span><span class="w"> </span><span class="nf">[L U] = slu</span><span class="p">(</span>A<span class="p">)</span>
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="c">% Square  factonzation with no row exchanges!</span>
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">A</span><span class="p">);</span><span class="w"> </span><span class="n">tol</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">I</span><span class="p">.</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">;</span>
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">n</span>
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="k">if</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tol</span>
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="k">end</span><span class="w"> </span><span class="c">% Cannot proceed without a row exchange: stop</span>
<a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a><span class="n">L</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a><span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">n</span>
<a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a><span class="n">L</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"> </span><span class="c">% Multipliers for column k are put into L</span>
<a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a><span class="k">for</span><span class="w"> </span><span class="nb">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="c">% Elimination beyond row k and column k</span>
<a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a><span class="n">A</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="w"> </span><span class="nb">j</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="w"> </span><span class="nb">j</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">L</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="nb">j</span><span class="p">);</span><span class="w"> </span><span class="c">% Matrix still called A</span>
<a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a><span class="k">end</span>
<a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a><span class="k">end</span>
<a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a><span class="k">for</span><span class="w"> </span><span class="nb">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">n</span>
<a id="__codelineno-1-15" name="__codelineno-1-15" href="#__codelineno-1-15"></a><span class="n">U</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="nb">j</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="nb">j</span><span class="p">);</span><span class="w"> </span><span class="c">% row k is settled, now name it U</span>
<a id="__codelineno-1-16" name="__codelineno-1-16" href="#__codelineno-1-16"></a><span class="k">end</span>
<a id="__codelineno-1-17" name="__codelineno-1-17" href="#__codelineno-1-17"></a><span class="k">end</span>
<a id="__codelineno-1-18" name="__codelineno-1-18" href="#__codelineno-1-18"></a>
<a id="__codelineno-1-19" name="__codelineno-1-19" href="#__codelineno-1-19"></a>
<a id="__codelineno-1-20" name="__codelineno-1-20" href="#__codelineno-1-20"></a>
<a id="__codelineno-1-21" name="__codelineno-1-21" href="#__codelineno-1-21"></a><span class="k">function</span><span class="w"> </span><span class="nf">[L U] = slv</span><span class="p">(</span>A<span class="p">)</span>
<a id="__codelineno-1-22" name="__codelineno-1-22" href="#__codelineno-1-22"></a><span class="c">% Solve Ax = b using L and U from slu(A).</span>
<a id="__codelineno-1-23" name="__codelineno-1-23" href="#__codelineno-1-23"></a><span class="p">[</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">slu</span><span class="p">(</span><span class="n">A</span><span class="p">);</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c">% No row exchanges!</span>
<a id="__codelineno-1-24" name="__codelineno-1-24" href="#__codelineno-1-24"></a><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="c">% Forward elimination to solve Lc = b</span>
<a id="__codelineno-1-25" name="__codelineno-1-25" href="#__codelineno-1-25"></a><span class="k">for</span><span class="w"> </span><span class="nb">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<a id="__codelineno-1-26" name="__codelineno-1-26" href="#__codelineno-1-26"></a><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="nb">j</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="nb">j</span><span class="p">));</span><span class="w"> </span><span class="c">% Add L times earlier c(j) before c(k)</span>
<a id="__codelineno-1-27" name="__codelineno-1-27" href="#__codelineno-1-27"></a><span class="k">end</span>
<a id="__codelineno-1-28" name="__codelineno-1-28" href="#__codelineno-1-28"></a><span class="n">c</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c">% Find c(k) and reset s for next k</span>
<a id="__codelineno-1-29" name="__codelineno-1-29" href="#__codelineno-1-29"></a><span class="k">end</span>
<a id="__codelineno-1-30" name="__codelineno-1-30" href="#__codelineno-1-30"></a><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c">% Going backwards from x(n) to x(1)</span>
<a id="__codelineno-1-31" name="__codelineno-1-31" href="#__codelineno-1-31"></a><span class="k">for</span><span class="w"> </span><span class="nb">j</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="c">% Back substitution</span>
<a id="__codelineno-1-32" name="__codelineno-1-32" href="#__codelineno-1-32"></a><span class="n">t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">U</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="nb">j</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="nb">j</span><span class="p">);</span><span class="w"> </span><span class="c">% U times later x(j))</span>
<a id="__codelineno-1-33" name="__codelineno-1-33" href="#__codelineno-1-33"></a><span class="k">end</span>
<a id="__codelineno-1-34" name="__codelineno-1-34" href="#__codelineno-1-34"></a><span class="n">x</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="w"> </span><span class="n">U</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span><span class="w"> </span><span class="c">% Divide by pivot</span>
<a id="__codelineno-1-35" name="__codelineno-1-35" href="#__codelineno-1-35"></a><span class="k">end</span>
<a id="__codelineno-1-36" name="__codelineno-1-36" href="#__codelineno-1-36"></a><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">x</span><span class="o">&#39;</span><span class="p">;</span><span class="w"> </span><span class="c">% Transpose to column vector</span>
</code></pre></div>
<p>求解Ax=b需要耗费多少呢?对于一个n=1000阶的随机矩阵,一个典型的时间是1秒.看 <code>web.mit.edu/18.06</code> 和<code>math.mit.edu/linearalgebra</code> 来得到在Matlab,Maple,Mathematica,CciLab,Python,R运行的时间..当n乘以2的时候,时间大概乘以8.如果需要专特代码,请看 <code>netlib.org</code>.</p>
<p>根据这个 <span class="arithmatex">\(n^3\)</span> 规则,10倍大的矩阵(10000阶)需要1000秒,而100,000需要100万秒.没有超级计算机的话,太昂贵了,但是记住,这些矩阵都是满矩阵,很多矩阵实际上是稀疏的,这时候 <code>A  = LU</code> 快很多.</p>
<p>对于三对角矩阵(tridiagonal matrices),假设10,000的话,我们只需要存储非0的元素,这时候求解 <code>Ax = b</code> 是轻而易举的事情,但是前提是代码能识别A是三对角矩阵.</p>
<h2 id="65">6.5. 关键概念</h2>
<ol>
<li>高斯消去把A分解成LU(没有行交换)</li>
<li>下三角矩阵包含了数字 <span class="arithmatex">\(\ell_{ij}\)</span>,这些数字是用来乘以主元行的，最终把A变成了LU。LU把U的行加起来，可以把U恢复成A.</li>
<li>右侧,我们求解的是Lc = b(向前),然后是Ux = c(向后替换)</li>
<li>分解:在左侧有 <span class="arithmatex">\(1/3 (n^3  −n)\)</span> 次乘法和减法</li>
<li>求解:有右侧,有 <span class="arithmatex">\(n^2\)</span> 次乘法和减法</li>
<li>对于带状矩阵, <span class="arithmatex">\(1/3 n^3\)</span> 变成 <span class="arithmatex">\(nw^2\)</span> , <span class="arithmatex">\(n^2\)</span> 变成 <span class="arithmatex">\(2wn\)</span></li>
</ol>
<h2 id="66">6.6. 典型例题</h2>
<p><strong>1.</strong> 我们已经在 <code>&lt;#5&gt; 典型例题2</code> 用GJ方法求出了下三角帕斯卡矩阵L的逆。现在我们把 L 和 对称帕斯卡矩阵 P 以及 上三角 U 联系起来。对称的帕斯卡P，每个元素都是上边元素和左边元素的和。n-n的对称P，在matlab中可用 <code>oascal(n)</code> 得到。现在我们来建立令人惊奇的 lower-upper 分解 : P = LU
$$
\text{psacal(4)} = \left[ \begin{array} { c c c c } 1 &amp; 1 &amp; 1 &amp; 1 \ 1 &amp; 2 &amp; 3 &amp; 4 \ 1 &amp; 3 &amp; 6 &amp; 10 \ 1 &amp; 4 &amp; 10 &amp; 20 \end{array} \right] = \left[ \begin{array} { l l l l } 1 &amp; 0 &amp; 0 &amp; 0 \ 1 &amp; 1 &amp; 0 &amp; 0 \ 1 &amp; 2 &amp; 1 &amp; 0 \ 1 &amp; 3 &amp; 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l l l l } 1 &amp; 1 &amp; 1 &amp; 1 \ 0 &amp; 1 &amp; 2 &amp; 3 \ 0 &amp; 0 &amp; 1 &amp; 3 \ 0 &amp; 0 &amp; 0 &amp; 1 \end{array} \right] = L U .
$$
P分解成U的过程是
$$
P = \left[ \begin{array} { c c c c } 1 &amp; 1 &amp; 1 &amp; 1 \ 1 &amp; 2 &amp; 3 &amp; 4 \ 1 &amp; 3 &amp; 6 &amp; 10 \ 1 &amp; 4 &amp; 10 &amp; 20 \end{array} \right] </p>
<p>\overset{\ell_{21},\ell_{31}，\ell_{41}=1}{\rightarrow }</p>
<p>\left[ \begin{array} { c c c c } 1 &amp; 1 &amp; 1 &amp; 1 \ 0 &amp; 1 &amp; 2 &amp; 3 \ 0 &amp; 2 &amp; 5 &amp; 9 \ 0 &amp; 3 &amp; 9 &amp; 19 \end{array} \right] </p>
<p>\overset{\ell_{32}=2，\ell_{42}=3}{\rightarrow }</p>
<p>\left[ \begin{array} { c c c c } 1 &amp; 1 &amp; 1 &amp; 1 \ 0 &amp; 1 &amp; 2 &amp; 3 \ 0 &amp; 0 &amp; 1 &amp; 3 \ 0 &amp; 0 &amp; 3 &amp; 10 \end{array} \right] </p>
<p>\overset{\ell_{43}=3}{\rightarrow }</p>
<p>\left[ \begin{array} { l l l l } 1 &amp; 1 &amp; 1 &amp; 1 \ 0 &amp; 1 &amp; 2 &amp; 3 \ 0 &amp; 0 &amp; 1 &amp; 3 \ 0 &amp; 0 &amp; 0 &amp; 1 \end{array} \right] = U
$$
可以看见，乘数 <span class="arithmatex">\(\ell_{ij}\)</span> 完美的填充进 L。在下一节，我们会展示，对称矩阵的L和U有特别的联系。对于如上的帕斯卡矩阵，U就是L的转置。</p>
<p>你可能希望 Matlab 的 <code>lu(pascal(4))</code> 命令产生如上的L，U。但其实不会，因为 <code>lu</code> 命令会挑选每一列的最大的元素作为主元。所以第2列的主元从1变成3.但 <code>Cholesky factorization</code> 没有行交换 :<code>U = chol(pascal(4))</code></p>
<p>帕斯卡矩阵有非常多令人惊奇的性质，我们还会遇见它的。</p>
<hr />
<p><strong>2.</strong> 上一题我们已经求解了P的LU，使用2个三角系统：<code>Lc = b,Ux = c</code>求解 <code>Px = b = (1,0,0,0)</code> 。对于这个b，意味着 x 是 <span class="arithmatex">\(P^{-1}\)</span> 的第一列</p>
<p><strong>解：</strong> Lc = b 的三角系统从上到下求解：
$$
\begin{array} { l l l } c _ { 1 } &amp; = 1 &amp; c _ { 1 } = + 1 \ c _ { 1 } + c _ { 2 } &amp; = 0 &amp; c _ { 2 } = - 1 \ c _ { 1 } + 2 c _ { 2 } + c _ { 3 } &amp; = 0 &amp; c _ { 3 } = + 1 \ c _ { 1 } + 3 c _ { 2 } + 3 c _ { 3 } + c _ { 4 } &amp; = 0 &amp; c _ { 4 } = - 1 \end{array}
$$
而解 x 是从下到上向后替换得到
$$
\begin{aligned} x _ { 1 } + x _ { 2 } + x _ { 3 } + x _ { 4 } &amp; = 1 &amp; &amp; x _ { 1 } = + 4 \ x _ { 2 } + 2 x _ { 3 } + 3 x _ { 4 } &amp; = - 1 &amp; \text { gives }\quad &amp; x _ { 2 } = - 6 \ x _ { 3 } + 3 x _ { 4 } &amp; = 1 &amp; &amp; x _ { 3 } = + 4 \ x _ { 4 } &amp; = - 1 &amp; &amp; x _ { 4 } = - 1 \end{aligned}
$$
x还有有一个模式啊，是什么呢？试试 <code>inv(pascal(4))</code>:</p>
<p><img alt="image-20210107171825654" src="../.assets/image-20210107171825654.png" /></p>
<h1 id="7">7. 转置和排列</h1>
<blockquote>
<p>Transposes and Permutations</p>
</blockquote>
<p>A的转置，用 <span class="arithmatex">\(A^{T}\)</span> 表示，<span class="arithmatex">\(A^{T}\)</span> 的列，就是A的行，转置的公式其实就是
$$
\text{交换行和列：} \quad  (A^T)<em ji="ji">{ij}= A</em>
$$
转置的规则是很直观的,A+B的转置是<span class="arithmatex">\((A+B)^T\)</span>,其实也就是 <span class="arithmatex">\(A^T+ B^T\)</span>,也就是说可以逐个转置。比较值得注意的是乘积AB的转置和逆矩阵 <span class="arithmatex">\(A^{−1}\)</span> 的转置
$$
\begin{aligned}</p>
<p>\text{Sum： A+B 的转置是:} \qquad   &amp;A^T+ B^T  \qquad \qquad (1) \
\text{Product： AB 的转置是:} \qquad   &amp;(AB)^T = B^TA^T \qquad (2) \
\text{Inverse：} A^{-1} \text{ 的转置是:} \qquad   &amp;(A^{-1})^T = (A^T)^{-1} \qquad (3) \</p>
<p>\end{aligned}
$$</p>
<p>反顺序的 <span class="arithmatex">\((AB)^T = B^T A^T\)</span> 值得注意,为了理解,从<span class="arithmatex">\((Ax)^T= x^T A^T\)</span> 开始,==<strong>Ax 组合A的列,而 <span class="arithmatex">\(x^T A^T\)</span> 组合 <span class="arithmatex">\(A^T\)</span> 的行</strong>==,这其实是对相同向量组的相同的线性组合!在A的时候是列向量, <span class="arithmatex">\(A^T\)</span> 是行向量,所以对列 <code>Ax</code> 的转置是 <span class="arithmatex">\(x^T A^T\)</span>.公式 <span class="arithmatex">\((Ax)^T= x^T A^T\)</span> 是吻合的,现在开始证明<span class="arithmatex">\((AB)^T= B^T A^T\)</span>,B多列</p>
<p>如果 <span class="arithmatex">\(B = [x_1,x_2]\)</span>,有两列,对每一列都应用相同的思想,AB的列是 <span class="arithmatex">\(Ax_1\)</span> 和 <span class="arithmatex">\(Ax_2\)</span>.它们的转置是 <span class="arithmatex">\(B^T A^T\)</span> 的行
$$
\text{转置} \quad A B = \left[ \begin{array} { l l l } A x _ { 1 } &amp; A x _ { 2 } &amp; \cdots \end{array} \right] \text { 得到 } \left[ \begin{array} { c } x _ { 1 } ^ { \mathrm { T } } A ^ { \mathrm { T } } \ x _ { 2 } ^ { \mathrm { T } } A ^ { \mathrm { T } } \ \vdots \end{array} \right] \text { 也就是  } B ^ { \mathrm { T } } A ^ { \mathrm { T } } \tag{4}
$$
这个规则可以扩展到多个:<span class="arithmatex">\((ABC)^T= C^T B^T A^T\)</span>。<strong>对于分解： A = LDU, <span class="arithmatex">\(A^T = U^TD^TL^T\)</span>,其中,主元矩阵 <span class="arithmatex">\(D = D^T\)</span>。</strong> 现在把这个规则应用到 <span class="arithmatex">\(A^{−1} A=I\)</span>,得到
$$
\text{逆矩阵的转置:}\quad  A^{-1}A = I \quad \text{转置为} \quad A^T(A^{-1})^T = I \tag{5}
$$</p>
<p>也就是说 <span class="arithmatex">\((A^T)^{−1}= (A^{−1})^T\)</span>,特别注意, <strong><span class="arithmatex">\(A^T\)</span> 是可逆的,当且仅当A是可逆的</strong>。</p>
<h2 id="71">7.1. 点乘的意义</h2>
<blockquote>
<p>The meaning of inner Product </p>
</blockquote>
<p>对于点乘 <span class="arithmatex">\(x \cdot y\)</span>,用矩阵的语言与更好的写法：</p>
<ul>
<li><span class="arithmatex">\(^T\)</span> 在里面: 点乘或者内乘是： <span class="arithmatex">\(x^Ty\)</span>, 是 <span class="arithmatex">\([1,n] [n,1]\)</span> ,一个数字</li>
<li><span class="arithmatex">\(^T\)</span> 在外面: <strong>秩1</strong>乘法或者<strong>外</strong>乘是： <span class="arithmatex">\(xy^T\)</span>, 是 <span class="arithmatex">\([n,1] [1,n]\)</span>,一个矩阵</li>
</ul>
<p>我们非常接近应用数学的核心了，但还有一点需要强调，是关于点乘和A的转置的深深联系：我们定义 <span class="arithmatex">\(A^T\)</span> 是关于A的对角线的翻转。这有点不数学，有更好的方法：<span class="arithmatex">\(A^T\)</span> 是对任何x,y，都能使得下面等式成立的矩阵：
$$
( A x ) ^ { \mathrm { T } } y = x ^ { T } \left( A ^ { \mathrm { T } } y \right) \quad  \text{Ax 和 y 的点乘}   =    x 和 A^Ty 的点乘
$$</p>
<blockquote>
<p>sp:注意上面左右都是 <strong>数字</strong>。</p>
</blockquote>
<p><strong>例1</strong> 看如下向量和和<strong>差分</strong>矩阵
$$
A = \left[ \begin{array} { r r r } - 1 &amp; 1 &amp; 0 \ 0 &amp; - 1 &amp; 1 \end{array} \right] \quad x = \left[ \begin{array} { l } x _ { 1 } \ x _ { 2 } \ x _ { 3 } \end{array} \right] \quad y = \left[ \begin{array} { l } y _ { 1 } \ y _ { 2 } \end{array} \right]
$$
那么有:
$$
(Ax)^Ty = (x_2  − x_1)y_1+(x_3  − x_2)y_2 
$$
<span class="arithmatex">\(A^T\)</span> 必须是 
$$
A ^ { \mathrm { T } } = \left[ \begin{array} { r r } - 1 &amp; 0 \ 1 &amp; - 1 \ 0 &amp; 1 \end{array} \right]
$$
验证一下
$$
A^Ty = \left[\begin{matrix} 
-y_1  \
y_1 - y_2  \
y_2  \
\end{matrix} \right]</p>
<p>\Rightarrow \quad </p>
<p>x^T (A^T y)= x_1 (−y_1 )+ x_2 (y_1−y_2 )+ x_3 (y_2 )
$$
结果和期望一致.</p>
<blockquote>
<p>sp:再看一下习题6，更直观的理解</p>
</blockquote>
<hr />
<p><strong>例2</strong> 可以提一下微积分吗，这真的很重要，不然我不会离开线代的主题。(这就是线性代数方式下的函数 <code>x(t)</code> ).例1的差分矩阵的作用是一个导函数  <code>A = d/dt</code>(sp:参见<code>&lt;01-01&gt; #4.2</code>,那里提到过差分矩阵就像是求导一样),它的转置来自于 <code>(dx/dt,y) = (x,dy/dt)</code> </p>
<p>根据定义,点乘是 <span class="arithmatex">\(x_ky_k\)</span> 的有限项求和,可以看成是函数 <code>x(t)y(t)</code> 的积分
$$
( x , y ) =  x ^ { \mathrm { T } } y  = \int _ { - \infty } ^ { \infty } x ( t ) y ( t ) d t
$$</p>
<blockquote>
<p>sp:上式最左边的 <code>(x,y)</code> 应该表示的就是 <code>x,y</code> 做点乘的意思,不然说不通啊</p>
</blockquote>
<p>根据转置规则 $( A x ) ^ { \mathrm { T } } y = x ^ { T } \left( A ^ { \mathrm { T } } y \right) $:
$$
(Ax,y) =  (x,A^Ty) \Rightarrow \quad  \int _ { - \infty } ^ { \infty } \frac { d x } { d t } y ( t ) d t = \int _ { - \infty } ^ { \infty } x ( t ) \left( - \frac { d y } { d t } \right) d t   \tag{6}
$$</p>
<p>希望你看懂了上面<strong>分部积分</strong>(sp:参见 <code>&lt;calculus/01-09 #1&gt;</code>).<code>Eq(6)</code>当中,对左边 <code>x(t)</code> 的求导,转换到对右边 <code>y(t)</code> 的求导,这个过程需要添加一个负号.这告诉我们,<strong>对导数的转置,是这个导数的负数(sp:乘以-1的意思)(the "transpose" ofthe derivative is minus the derivative)</strong></p>
<p>导数是<strong>反对称(anti-symmetric)</strong>的, <span class="arithmatex">\(A = d/dt\)</span> , 而 <span class="arithmatex">\(A^T = -d/dt\)</span>.对称矩阵有 <span class="arithmatex">\(A = A^T\)</span>,而反对称矩阵是 <span class="arithmatex">\(A^T = - A\)</span>.以某种方式,例1的 2-3 差分矩阵是这种模式.  3-2 的 <span class="arithmatex">\(A^T\)</span> ,它在第2个分量,产生了 <span class="arithmatex">\(y_1 - y_2\)</span>,而不是 <span class="arithmatex">\(y_2 - y_1\)</span> (sp:是差分矩阵A的话,产生的就是 <span class="arithmatex">\(y_1-y_2\)</span>,而转置 <span class="arithmatex">\(A^T\)</span> 产生的恰好是乘以 <code>-1</code>)</p>
<blockquote>
<p>sp:总结一下这一题的思想吧,如果把<strong>差分A矩阵看成是求导,点乘的意义看成是积分</strong> ,那么<code>(6)</code> 在 <strong>线代方式下是成立的.</strong> <code>(6)</code> 有点像是微积分的分部积分.大概意思就是如此.</p>
<p>但这其实有点不对经,分部积分公式是
$$
\int _ { - \infty } ^ { \infty } \frac { d x } { d t } y ( t ) d t = \left. x ( t ) y ( t ) \right| _ { - \infty } ^ { \infty } - \int _ { - \infty } ^ { \infty } x ( t ) \frac { d y } { d t } d t
$$
如果是这种模式的话,那么<code>(6)</code> 最右边少了一个部分.所以上面说是 <strong>线代方式下</strong>. 这里应该只是强调转置操作有更多的意义.在 <a href="https://math.stackexchange.com/questions/2985768/how-does-the-transpose-of-the-derivative-equal-minus-the-derivative">stackexchange</a> 上也有这个讨论</p>
</blockquote>
<h2 id="72">7.2. 对称矩阵</h2>
<blockquote>
<p>Symmetric Matrices </p>
</blockquote>
<p>在我看来,对称矩阵是最重要的矩阵!</p>
<blockquote>
<p><strong>Definition</strong></p>
<hr />
<p>对称矩阵是 <span class="arithmatex">\(A^T = A\)</span>,这意味这 <span class="arithmatex">\(a_{ji} = a_{ij}\)</span></p>
</blockquote>
<p><strong>对称矩阵的逆矩阵还是对称矩阵</strong>,这是因为
$$
(A^{−1})^T= (A^T)^{−1}= A^{−1}
$$
所以 <span class="arithmatex">\(A^{−1}\)</span> 也是一个对称矩阵。非对称矩阵的逆矩阵也是非对称矩阵,参见习题2</p>
<h2 id="73-rt-rrrt-ldlt">7.3. 对称乘积 <span class="arithmatex">\(R^T R,RR^T  , LDL^T\)</span></h2>
<blockquote>
<p>Sysmetric Products <span class="arithmatex">\(R^T R\)</span>  and <span class="arithmatex">\(RR^T\)</span>  and <span class="arithmatex">\(LDL^T\)</span></p>
</blockquote>
<p>下面,我们通过<strong>==任何==矩阵 <span class="arithmatex">\(R,R^T\)</span> 来产生对称矩阵!</strong> 选择<strong>任何</strong>矩阵R,矩形也可, <span class="arithmatex">\(R^T\)</span> 和 <span class="arithmatex">\(R\)</span> 的乘积 <span class="arithmatex">\(R^TR\)</span> 就自动是一个<strong>对称==方阵==</strong>,这是因为:
$$
(R^TR)^T =   R^T(R^T)^T = R^TR \tag{7}. 
$$
<code>Eq(7)</code> 证明了 <span class="arithmatex">\(R^T R\)</span> 是一个对称矩阵. 我们还可以通过 <span class="arithmatex">\(R^T R\)</span> 的元素分析一下: <span class="arithmatex">\(R^T R\)</span> 的 <code>(i,j)</code> 元素是 <span class="arithmatex">\(R^T\)</span> 的 <code>行i</code> (R的<code>列i</code> ) 乘以R的<code>列j</code>.而 <code>(j,i)</code> 位置的元素也是R的 <code>列j</code> 和 <code>列i</code> 的点乘,所以 <span class="arithmatex">\(R^T R\)</span> 是对称的</p>
<p><span class="arithmatex">\(RR^T\)</span> 也是对称的,但是和 <span class="arithmatex">\(R^TR\)</span>的形状是不一样的,如果R 是 <code>m-n</code> 矩阵</p>
<ul>
<li><span class="arithmatex">\(R^T R\)</span> 是 <code>[n n]</code></li>
<li><span class="arithmatex">\(RR^T\)</span> 是 <code>[m-m]</code></li>
</ul>
<p>就算 <code>m=n</code> , <span class="arithmatex">\(R^T R\)</span> 和 <span class="arithmatex">\(RR^T\)</span> 都基本上不一样! 注意, <span class="arithmatex">\(RR^T\)</span> 和 <span class="arithmatex">\(R^T R\)</span> 的<strong>主对角线的元素都是正值的</strong>(参见例4).在经验当中,<strong>大多数从矩形矩阵R开始的科学问题,基本上都是以 <span class="arithmatex">\(R^TR,RR^T\)</span> 的方式进行的!</strong>最起码对最小二乘是如此.(sp:所以这很重要)</p>
<p><strong>例3</strong> 设 <span class="arithmatex">\(R = \left[ \begin{array} { r r r } - 1 &amp; 1 &amp; 0 \\ 0 &amp; - 1 &amp; 1 \end{array} \right]\)</span>,那么进行一下乘法
$$
R R ^ { T } = \left[ \begin{array} { r r } 2 &amp; - 1 \ - 1 &amp; 2 \end{array} \right] \quad  R ^ { \mathrm { T } } R = \left[ \begin{array} { r r r } 1 &amp; - 1 &amp; 0 \ - 1 &amp; 2 &amp; - 1 \ 0 &amp; - 1 &amp; 1 \end{array} \right]
$$
都是对称矩阵.而且对角线的主元都是正值,因为对角线的元素<strong>来自于列和自身的点乘</strong>.</p>
<h3 id="731">7.3.1. 消去当中的对称矩阵</h3>
<blockquote>
<p>Sysmmetric matrices in elimination </p>
</blockquote>
<p><span class="arithmatex">\(A^T=A\)</span> 让消去过程进行的更快,因为我们可以只对一半矩阵(包括对角线)进行操作.确实,上三角U大概率不是对称的,<strong>对称存在于3矩阵乘法 <code>A = LDU</code></strong> .记住由主元构成的对角矩阵 <code>D</code> 的元素可以被除,从而让L,U的对角线的值都是1
$$
\begin{aligned} </p>
<p>\left[ \begin{array} { l l } 1 &amp; 2 \ 2 &amp; 7 \end{array} \right] </p>
<p>&amp; = \left[ \begin{array} { l l } 1 &amp; 0 \ 2 &amp; 1 \end{array} \right] </p>
<p>\left[ \begin{array} { l l } 1 &amp; 2 \ 0 &amp; 3 \end{array} \right] </p>
<p>\color{orange} \text{LU没有捕捉到A的对称性}</p>
<p>\ </p>
<p>&amp; = </p>
<p>\left[ \begin{array} { l l } 1 &amp; 0 \ 2 &amp; 1 \end{array} \right]  \left[ \begin{array} { l l } 1 &amp; 0 \ 0 &amp; 3 \end{array} \right] </p>
<p>\left[ \begin{array} { l l } 1 &amp; 2 \ 0 &amp; 1 \end{array} \right] </p>
<p>\color{orange} \text{LDU捕捉到了A的对称性,U就是} L^T!</p>
<p>\end{aligned}
$$
当A是对称的, <code>A = LDU</code> 就可以变成 <span class="arithmatex">\(A = LDL^T\)</span> ,<strong>最终U(主对角线是1)变成 <span class="arithmatex">\(L^T\)</span>,而包含主元的对角矩阵D,本身就是对称的</strong></p>
<blockquote>
<p><strong>NOTE</strong></p>
<hr />
<p>如果 <span class="arithmatex">\(A = A^T\)</span> 被没有行交换的分解为 LDU, 那么U其实就是 <span class="arithmatex">\(L^T\)</span>.对称矩阵的对称分解(symmetric factorization)是 <span class="arithmatex">\(A = LDL^T\)</span></p>
</blockquote>
<p>注意,<span class="arithmatex">\(LDL^T\)</span> 的转置是 <span class="arithmatex">\(L^{TT} D^T L^T= LDL^T\)</span> ! 从侧面说明了对称性.消去的耗费就可以减少一半,从 <span class="arithmatex">\(n^3/3\)</span> 变成 <span class="arithmatex">\(n^3/6\)</span>.需要的存储基本上也减少一半,我们只需要保存 <span class="arithmatex">\(L,D\)</span>,因为U就是 <span class="arithmatex">\(L^T\)</span></p>
<h2 id="74">7.4. 置换矩阵</h2>
<blockquote>
<p>Permutation matrices</p>
</blockquote>
<p>转置在置换矩阵当中有特殊的作用.<code>P</code> 矩阵的每一行一列都只有一个1.那么 <span class="arithmatex">\(P^T\)</span> 也是一个置换矩阵-可能和P相同也可能不是,任何乘积 <span class="arithmatex">\(P_1 P_2\)</span> 也是一个置换矩阵.重排列 <code>I</code> 的行,就可以得到所有的置换矩阵.</p>
<p>最简单的置换矩阵就是<code>I</code>(没有行交换). 第二简单的就是 <span class="arithmatex">\(P_{ij}\)</span>,也就是交换 <code>I</code> 的 行<code>i</code> 和 行 <code>j</code>. 对<code>I</code> 进行所有可能的行交换,我们就得到的所有的置换矩阵:</p>
<blockquote>
<p><strong>Defintion</strong></p>
<hr />
<p>一个置换矩阵 P ,就是 <code>I</code> 的行以任意顺序分布</p>
</blockquote>
<p><strong>例4</strong> 3-3的矩阵有6个置换矩阵
$$
I = \left[ \begin{array} { c c c } 1 &amp; &amp; \ &amp; 1 &amp; \ &amp; &amp; 1 \end{array} \right] \quad </p>
<p>P _ { 21 } = \left[ \begin{array} { c c c } &amp; 1 &amp; \ 1 &amp; &amp; \ &amp; &amp; 1 \end{array} \right] \quad </p>
<p>P _ { 31 } = \left[ \begin{array} { c c c } &amp; &amp; 1 \ &amp; 1 &amp; \ 1 \end{array} \right] \quad </p>
<p>P _ { 32 } = \left[ \begin{array} { c c c } 1 &amp; &amp; \ &amp; &amp; 1 \ &amp; 1 &amp; \end{array} \right] \quad</p>
<p>\[6ex]</p>
<p>P _ { 21 } P _ { 32 } = \left[ \begin{array} { c c c } &amp; &amp; 1 \ 1 &amp; &amp;  \ &amp; 1 &amp; \end{array} \right]</p>
<p>P _ { 32 } P _ { 21 } = \left[ \begin{array} { c c c } &amp; 1 &amp; \ &amp;  &amp; 1 \ 1  &amp; &amp; \end{array} \right]
$$
n阶矩阵就有 <code>n!</code> 个置换矩阵.其实就是n的阶乘啊,所以叫置换</p>
<p><strong>重要</strong>,<span class="arithmatex">\(P^{−1}\)</span> 也是置换矩阵.在上面的6个置换矩阵当中</p>
<ul>
<li>前面4个矩阵的逆矩阵就是本身,一次行交换的置换矩阵的逆矩阵就是本身,而且 <span class="arithmatex">\(P^T = P \Rightarrow P^2 = I\)</span></li>
<li>后面2个矩阵互为逆矩阵.2次行交换的 <span class="arithmatex">\(P_{32} P_{21}\)</span>,如果需要恢复到 <code>I</code> ,顺序需要调转,所以它的逆矩阵是 <span class="arithmatex">\(P_{21} P_{32}\)</span></li>
</ul>
<p><strong>更重要</strong>:  <strong><span class="arithmatex">\(P^{−1}\)</span> 总是等于 <span class="arithmatex">\(P^T\)</span></strong> , 为什么呢? 当我们做 <span class="arithmatex">\(PP^T\)</span> 乘法, P 当中的第一行的<code>1</code>,总能遇到 <span class="arithmatex">\(P^T\)</span>第一列中的 <code>1</code>.其他也是如此,所以 <span class="arithmatex">\(PP^T=I\)</span> .</p>
<h2 id="75-pa-lu">7.5. 行交换的分解:PA = LU</h2>
<blockquote>
<p>The PA = LU Factorization with  row exchange</p>
</blockquote>
<p>我们以前讨论的都是没有行交换的,也就是 <span class="arithmatex">\(...E_{ij}...E_{21}A = U\)</span>,每一个消去步骤都是 <span class="arithmatex">\(E_{ij}\)</span> 的作用,并且可以被  <span class="arithmatex">\(E_{ij}^{-1}\)</span> 抵消,所以 <span class="arithmatex">\((A = E_{21}^-1...E_{ij}^{-1}...)U\)</span>.这些逆矩阵可以合并成一个 L ,从而 <span class="arithmatex">\(A = LU\)</span></p>
<p>这是很棒的分解,但是有时候不起作用啊,因为需要行交换产生主元.这种情况下,A = LU的形式是 <span class="arithmatex">\(A = (E^{−1}…P^{−1}…E^{−1}…P^{−1}…)U\)</span>.每一个的行交换是通过 <span class="arithmatex">\(P_{ij}\)</span> 进行的,也是通过 <span class="arithmatex">\(P_{ij}\)</span> 逆转的</p>
<blockquote>
<p>sp:因为 <span class="arithmatex">\(P_{ij}\)</span> 是一行交换的矩阵,逆矩阵和本身相等,再者,如前所述,置换矩阵的逆等于其本身</p>
</blockquote>
<p>这些,置换矩阵 <span class="arithmatex">\(P_{ij}\)</span> 可以组合到单一一个置换矩阵<code>P</code>,这样的话就可以给任何一个可逆矩阵A分解,这才是我们想要的.</p>
<p>那么现在的问题就是如何收集这些 <span class="arithmatex">\(P_{ij}\)</span>.有两种可能</p>
<ol>
<li>在消去之前就进行所有的行交换.
行交换可以提前进行,<strong>矩阵乘积</strong>P, 把 A 的行放置到合适的位置,所以对于 PA 不再需要再进行行交换,那么 <span class="arithmatex">\(PA= LU\)</span>
<span class="arithmatex">\(PA = LU\)</span>的形式在很多计算中使用(包括Matlab).所以==我们下面关注这个形式==.大多数数值计算,基本不会使用另外的方式</li>
<li>或者在消去<strong>完成</strong>之后,在<strong>所有</strong>的 <span class="arithmatex">\(E_{ij}\)</span> <strong>后</strong>进行行交换. 在消去完成后,主元的顺序很奇怪, <span class="arithmatex">\(P_1\)</span> 矩阵把 <span class="arithmatex">\(U_1\)</span> 的主元调整到正确的三角位置(correct triangular order),所以置换矩阵 <span class="arithmatex">\(P_1\)</span> 在中间,也就是 <span class="arithmatex">\(A = L_1P_1U_1\)</span></li>
</ol>
<blockquote>
<p>sp:首先要知道,其实只要矩阵可逆,就可以消去,不然根本没有完整的主元..所以上面的方式2的意思是,先完全进行消去,但这样以后,<span class="arithmatex">\(U_1\)</span> 就不是上三角的,所以有 <span class="arithmatex">\(P_1\)</span> 来调整 <span class="arithmatex">\(U_1\)</span> 里面的主元.也就是</p>
<p><span class="arithmatex">\(PEA = U_1 \rightarrow A= E^{-1}P^{-1} U_1\)</span>，左边的E可能表示多个消去，最后由P切换到上三角的 <span class="arithmatex">\(U_1\)</span>。  而右边 <span class="arithmatex">\(E^{-1}\)</span> 就是 <span class="arithmatex">\(L_1\)</span>,而且 <span class="arithmatex">\(P^{-1}\)</span> 本身也是一个置换矩阵，所以可以写成 <span class="arithmatex">\(A = L_1P_1U_1\)</span>,参见习题4.</p>
<p>但方式1才是常用的</p>
</blockquote>
<p>对于下面的矩阵A,r1,r2交换之后,就可以不断消去了,是方式1.
$$
\underbrace{\left[ \begin{array} { l l l } 0 &amp; 1 &amp; 1 \ 1 &amp; 2 &amp; 1 \ 2 &amp; 7 &amp; 9 \end{array} \right]}_A \rightarrow </p>
<p>\underbrace{\left[ \begin{array} { l l l } 1 &amp; 2 &amp; 1 \ 0 &amp; 1 &amp; 1 \ 2 &amp; 7 &amp; 9 \end{array} \right]}_{PA} </p>
<p>\rightarrow </p>
<p>\underbrace{\left[ \begin{array} { l l l } 1 &amp; 2 &amp; 1 \ 0 &amp; 1 &amp; 1 \ 0 &amp; 3 &amp; 7 \end{array} \right] }<em 31="31">{\ell</em>} = 2</p>
<p>\rightarrow </p>
<p>\underbrace{\left[ \begin{array} { l l l } 1 &amp; 2 &amp; 1 \ 0 &amp; 1 &amp; 1 \ 0 &amp; 0 &amp; 4 \end{array} \right]}_{\ell{32 = 3}}
$$
如下是P和PA,PA各行的顺序都很好,从而像以前一样分解为LU
$$
\boldsymbol { P } = \left[ \begin{array} { l l l } 0 &amp; 1  &amp; 0 \ \ 1  &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] \quad P A = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 2 &amp; 3 &amp; 1 \end{array} \right] \left[ \begin{array} { l l l } 1 &amp; 2 &amp; 1 \ 0 &amp; 1 &amp; 1 \ 0 &amp; 0 &amp; 4 \end{array} \right] = L U</p>
<p>\tag{8}
$$</p>
<p>从A开始我们最终得到了U,<strong>唯一的要求就是A的可逆性</strong></p>
<blockquote>
<p><strong>NOTE</strong></p>
<hr />
<p>如果A是可逆的,那么一个置换的P矩阵,将会把A的所有行,都放置到合适的位置,从而 <span class="arithmatex">\(PA= LU\)</span>.而A的可逆性,要求行交换后,需要有完整的主元</p>
</blockquote>
<hr />
<p>在 Matlab, <code>A([r k],:) = A([k r],:)</code> 是交行 <code>k</code> 和之下 行 <code>r</code>  的方式.然后 <code>LU</code> 代码更新 <code>L,P</code> 和 <code>P</code> 的正负性.下面是 <code>[L,U,P] = lu(A)</code> 代码的一部分(sp：下面代码没有研究）</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="n">A</span><span class="p">([</span><span class="n">r</span><span class="w"> </span><span class="n">k</span><span class="p">],:)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">A</span><span class="p">([</span><span class="n">k</span><span class="w"> </span><span class="n">r</span><span class="p">],:);</span><span class="w">            </span><span class="c">% 交换A的行k,行 r</span>
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="n">L</span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">k</span><span class="p">],</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)=</span><span class="n">L</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="n">r</span><span class="p">],</span><span class="mi">1</span><span class="w"> </span><span class="p">:</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="w">       </span><span class="c">% </span>
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="n">P</span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="n">k</span><span class="p">],:)</span><span class="w"> </span><span class="p">=</span><span class="n">P</span><span class="p">([</span><span class="n">k</span><span class="w"> </span><span class="n">r</span><span class="p">],:);</span><span class="w">              </span><span class="c">% 交换P的行k,行 r</span>
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a><span class="nb">sign</span><span class="w"> </span><span class="p">=</span><span class="o">-</span><span class="nb">sign</span>
</code></pre></div>
<p><code>sign</code>的正负性会告诉我们行交换的奇偶性,负数就表示是奇数次行交换.在开始的时候,<code>P</code> 是<code>I</code>,<code>sign = +1</code>. <code>sign</code> 最终的值就是P的行列式,而且不取决于行交换的顺序</p>
<p>对于PA,我们最终得到了熟悉的LU.在时间当中,<code>lu(A)</code> 通常不使用第一个可用的主元.因为虽然在数学上我们接受很小的主元,主要不是0即可,但在实践当中,由计算机查找一整列寻找最大的可用主元,是更好的.(<code>&lt;01-09 #1&gt;</code> 会解释,为什么这种 <strong>partial pivoting</strong> 技巧可以降低舍去误差(roundoff error)).所以P最终会包含一些不是代数需要的行交换,但最终还是 <span class="arithmatex">\(PA = LU\)</span></p>
<p>建议是,知道原理,然后让计算机去实际的计算.A = LU的计算,手动做的话,已经很复杂了. 代码.在 <code>&lt;A10-01.md&gt;</code>,代码  </p>
<ul>
<li><code>splu(A)</code> 分解 PA = LU,如果第k列找不到主元,就会停止,因为这表示A不可逆</li>
<li><code>splv(A)</code> 对任何可逆的A求解 Ax  = b.</li>
</ul>
<h2 id="76">7.6. 典型例题</h2>
<p><strong>1.</strong> 对 A 应用P,破坏了A的对称性
$$
P = \left[ \begin{array} { l l l } 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \ 1 &amp; 0 &amp; 0 \end{array} \right] \quad A = \left[ \begin{array} { l l l } 1 &amp; 4 &amp; 5 \ 4 &amp; 2 &amp; 6 \ 5 &amp; 6 &amp; 3 \end{array} \right] \quad P A = \left[ \begin{array} { l l l } 4 &amp; 2 &amp; 6 \ 5 &amp; 6 &amp; 3 \ 1 &amp; 4 &amp; 5 \end{array} \right]
$$
什么矩阵Q,当作用到 PA 的<strong>列</strong> 上的时候,也就是 PAQ,可以恢复A的对称性? (A的主对角线必须要是1,2,3,但可能不是这个顺序).再证明,<span class="arithmatex">\(Q = P^T\)</span>,所以对称性可由 <span class="arithmatex">\(PAQ = PAP^T\)</span> 存储.</p>
<p>解:为了恢复对称性，需要把1，2，3放回对角线去。那么</p>
<ul>
<li>PA 的 C2 需要放到 C1</li>
<li>PA 的 C3  需要放到 C2</li>
<li>PA 的 C1 需要放到 C3</li>
</ul>
<p>这样，对角线元素变成 <code>2 3 1</code>,可以推出：
$$
P A = \left[ \begin{array} { l l l } 4 &amp; 2 &amp; 6 \ 5 &amp; 6 &amp; 3 \ 1 &amp; 4 &amp; 5 \end{array} \right] \quad Q = \left[ \begin{array} { l l l } 0 &amp; 0 &amp; 1 \ 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \end{array} \right] \quad P A Q = \left[ \begin{array} { l l l } 2 &amp; 6 &amp; 4 \ 6 &amp; 3 &amp; 5 \ 4 &amp; 5 &amp; 1 \end{array} \right] \text{是对称的}
$$
可以看出：<span class="arithmatex">\(Q = P^T\)</span>.其实，如果选择 <span class="arithmatex">\(Q = P^T\)</span>,总能恢复对称性。<strong>因为 <span class="arithmatex">\(PAP^T\)</span> 肯定是对称的！</strong>。Q其实也是 <span class="arithmatex">\(Q^{-1}\)</span>,因为置换矩阵的逆等于其转置</p>
<p><strong>如果D是对角矩阵，那么 <span class="arithmatex">\(PDP^T\)</span> 也是对角的</strong>。当左边的P移动 r1到r3,右边的 <span class="arithmatex">\(P^T\)</span> 会移动 C1 到 C3.分析一下 <code>(1,1)</code> 元素可以发现，它刚开始移动到 <code>（3,1）</code> ,然后移动到 <code>(3,3)</code></p>
<hr />
<p><strong>2.</strong>  对例1的A求分解 <span class="arithmatex">\(A = LDL^T\)</span> ,A是否可逆？对Q也求分解 <span class="arithmatex">\(PQ = LU\)</span>,注意这里需要行交换</p>
<p>解： 首先我们对AJ进行消去得到U
$$
A = \left[ \begin{array} { l l l } 1 &amp; 4 &amp; 5 \ 4 &amp; 2 &amp; 6 \ 5 &amp; 6 &amp; 3 \end{array} \right] </p>
<p>\overset{\ell_{21} = 4,\ell_{31}= 5}{\rightarrow}</p>
<p>\left[ \begin{array} { c c c } 1 &amp; 4 &amp; 5 \ 0 &amp; - 14 &amp; - 14 \ 0 &amp; - 14 &amp; - 22 \end{array} \right] </p>
<p>\overset{\ell_{32} = 1}{\rightarrow}</p>
<p>\left[ \begin{array} { c c c } 1 &amp; 4 &amp; 5 \ 0 &amp; - 14 &amp; - 14 \ 0 &amp; 0 &amp; - 8 \end{array} \right] = U
$$
现在将U的行分别除以U所在的主元，得到 LDU分解:
$$
A = L D L ^ { T } = \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 4 &amp; 1 &amp; 0 \ 5 &amp; 1 &amp; 1 \end{array} \right] \left[ \begin{array} { l l l } 1 &amp; &amp; \ &amp; - 14 &amp; \ &amp; &amp; - 8 \end{array} \right] \left[ \begin{array} { l l l } 1 &amp; 4 &amp; 5 \ 0 &amp; 1 &amp; 1 \ 0 &amp; 0 &amp; 1 \end{array} \right]
$$
A是可逆的，因为有3个主元。<strong>它的逆矩阵是 <span class="arithmatex">\((L^T)^{-1} D^{-1} L^{-1}\)</span>,也是可逆的。</strong></p>
<p>任何置换矩阵 Q 都是可逆的，我们做一下下去，需要2次行交换：
$$
Q = \left[ \begin{array} { l l l } 0 &amp; 0 &amp; 1 \ 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \end{array} \right] \quad \begin{array} { l } \text { rows } \ \longrightarrow \ 1 \leftrightarrow 2 \end{array} \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 0 \end{array} \right] \quad \begin{array} { c } \text { rows } \ \longrightarrow \ 2 \leftrightarrow 3 \end{array} \left[ \begin{array} { l l l } 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right] = U = I
$$
所以，上面只需要行交换就可以完成消去，所以 <span class="arithmatex">\(E = L= I\)</span>,而且最终的U是<code>I</code>.哪么
$$
PQ = I  \Rightarrow Q^{-1} Q = I
$$
从这里就可以发现，置换矩阵A的消去其实就是再次以相反顺序交换行，最后的分解都是 <span class="arithmatex">\(PA = I\)</span></p>
<hr />
<p><strong>3.</strong> 一个<code>[m-n]</code> 的<strong>矩形</strong>的A，和 <code>m-m</code> 的 <code>I</code>,组成如下的 <code>saddle-point matrix</code>,是对称的！
$$
S = \left[ \begin{array} { c c } I &amp; A \ A ^ { \mathrm { T } } &amp; 0 \end{array} \right] = S ^ { \mathrm { T } } \text { 是 [m+n,m+n] 的方阵}  \quad \color{orange} \text{(来自最小二乘)}
$$
对S应用块消去(block elimination),得到<strong>块分解(block factorization)</strong>: <span class="arithmatex">\(S = LDL^T\)</span>,然后测试可逆性：
$$
S 可逆 \quad \Leftrightarrow \quad   A^TA 可逆 \quad  \Leftrightarrow \quad  只要x\ne 0,Ax \ne 0
$$
解：第一个<strong>块</strong>主元是<code>I</code>,第一行乘以<span class="arithmatex">\(A^T\)</span> 被第2行减去，可进行消去
$$
S = \left[ \begin{array} { c c } I &amp; A \ A ^ { \mathrm { T } } &amp; 0 \end{array} \right] \quad r_2 - r_1*A^T  \quad</p>
<p>\Rightarrow \left[ \begin{array} { c c } I &amp; A \ 0 &amp; - A ^ { \mathrm { T } } A \end{array} \right] = U
$$
那么，<strong>块</strong>主元矩阵 D 包含了 <code>I</code> 和 <span class="arithmatex">\(-A^TA\)</span>,这时候<span class="arithmatex">\(L，L^T\)</span> 分别包含 <span class="arithmatex">\(A^T\)</span> 和 A
$$
\text{Block factorization:} \quad </p>
<p>S = L D L ^ { \mathrm { T } } = \left[ \begin{array} { l l } I &amp; 0 \ A ^ { \mathrm { T } } &amp; I \end{array} \right] \left[ \begin{array} { c c } I &amp; 0 \ 0 &amp; - A ^ { \mathrm { T } } A \end{array} \right] \left[ \begin{array} { l l } I &amp; A \ 0 &amp; I \end{array} \right]
$$
<span class="arithmatex">\(L,L^T\)</span>的主对角线都是1，明显是可逆的.而 D 的逆涉及到 <span class="arithmatex">\((A^TA)^{-1}\)</span>,<code>&lt;01-04 #2&gt;</code> 会回答关于<span class="arithmatex">\(A^TA\)</span> 的关键问题</p>
<ul>
<li><strong><span class="arithmatex">\(A^TA\)</span> 什么时候可逆？A必须有独立的列</strong></li>
<li><strong>那么Ax = 0 当且仅当 x= 0.不然的话 <span class="arithmatex">\(Ax= 0\)</span> 会得到 <span class="arithmatex">\(A^TAx = 0\)</span></strong></li>
</ul>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy", "content.code.annotate", "content.action.edit", "content.tabs.link", "navigation.instant", "navigation.tracking", "navigation.tabs", "navigation.tabs.sticky", "navigation.path", "navigation.indexes", "navigation.top", "navigation.footer", "navigation.sections", "search.highlight", "search.share", "search.suggest", "header.autohide"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="https://cdn.tonycrane.cc/utils/katex.min.js"></script>
      
        <script src="../../../js/katex.js"></script>
      
    
  </body>
</html>